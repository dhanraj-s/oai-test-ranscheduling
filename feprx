executables/nr-gnb.c:  if (ru->feprx)
executables/nr-gnb.c:    output += print_meas_log(&ru->ofdm_demod_stats, "feprx", NULL, NULL, output, end - output);
executables/nr-gnb.c:  if (ru->feptx_prec) {
executables/nr-gnb.c:    output += print_meas_log(&ru->precoding_stats,"feptx_prec",NULL,NULL, output, end - output);
executables/nr-gnb.c:  if (ru->feptx_ofdm) {
executables/nr-gnb.c:    output += print_meas_log(&ru->txdataF_copy_stats,"txdataF_copy",NULL,NULL, output, end - output);
executables/nr-gnb.c:    output += print_meas_log(&ru->ofdm_mod_stats,"feptx_ofdm",NULL,NULL, output, end - output);
executables/nr-gnb.c:    output += print_meas_log(&ru->ofdm_total_stats,"feptx_total",NULL,NULL, output, end - output);
executables/nr-gnb.c:  if (ru->fh_north_asynch_in)
executables/nr-gnb.c:    output += print_meas_log(&ru->rx_fhaul,"rx_fhaul",NULL,NULL, output, end - output);
executables/nr-gnb.c:  output += print_meas_log(&ru->tx_fhaul,"tx_fhaul",NULL,NULL, output, end - output);
executables/nr-gnb.c:  if (ru->fh_north_out) {
executables/nr-gnb.c:    output += print_meas_log(&ru->compression,"compression",NULL,NULL, output, end - output);
executables/nr-gnb.c:    output += print_meas_log(&ru->transport,"transport",NULL,NULL, output, end - output);
executables/main_ru.c:  ru->ru_mask= &ru_mask;
executables/main_ru.c:  ru->ru_mutex = &ru_mutex;
executables/main_ru.c:  ru->ru_cond = &ru_cond;
executables/main_ru.c:  ru->if_timing = synch_to_ext_device;
executables/main_ru.c:  ru->num_eNB = 0;
executables/main_ru.c:  ru->has_ctrl_prt = 1;
executables/main_ru.c:    ru->openair0_cfg.sdr_addrs = strdup(*(RUParamList.paramarray[j][RU_SDR_ADDRS].strptr));
executables/main_ru.c:      ru->openair0_cfg.clock_source = internal;
executables/main_ru.c:      ru->openair0_cfg.clock_source = external;
executables/main_ru.c:      ru->openair0_cfg.clock_source = gpsdo;
executables/main_ru.c:    ru->openair0_cfg.clock_source = unset;
executables/main_ru.c:      ru->openair0_cfg.time_source = internal;
executables/main_ru.c:      ru->openair0_cfg.time_source = external;
executables/main_ru.c:      ru->openair0_cfg.time_source = gpsdo;
executables/main_ru.c:    ru->openair0_cfg.time_source = unset;
executables/main_ru.c:      ru->eth_params.local_if_name            = strdup(*(RUParamList.paramarray[j][RU_LOCAL_IF_NAME_IDX].strptr));
executables/main_ru.c:      ru->eth_params.my_addr                  = strdup(*(RUParamList.paramarray[j][RU_LOCAL_ADDRESS_IDX].strptr));
executables/main_ru.c:      ru->eth_params.remote_addr              = strdup(*(RUParamList.paramarray[j][RU_REMOTE_ADDRESS_IDX].strptr));
executables/main_ru.c:      ru->eth_params.my_portd                 = *(RUParamList.paramarray[j][RU_LOCAL_PORTD_IDX].uptr);
executables/main_ru.c:      ru->eth_params.remote_portd             = *(RUParamList.paramarray[j][RU_REMOTE_PORTD_IDX].uptr);
executables/main_ru.c:	ru->has_ctrl_prt            = 0;
executables/main_ru.c:	ru->eth_params.my_portc                 = *(RUParamList.paramarray[j][RU_LOCAL_PORTC_IDX].uptr);
executables/main_ru.c:	ru->eth_params.remote_portc             = *(RUParamList.paramarray[j][RU_REMOTE_PORTC_IDX].uptr);
executables/main_ru.c:	printf(" Control port %u \n",ru->eth_params.my_portc);
executables/main_ru.c:	ru->if_south                        = LOCAL_RF;
executables/main_ru.c:	ru->function                        = NGFI_RRU_IF5;
executables/main_ru.c:	ru->eth_params.transp_preference    = ETH_UDP_MODE;
executables/main_ru.c:	ru->if_south                        = LOCAL_RF;
executables/main_ru.c:	ru->function                        = NGFI_RRU_IF5;
executables/main_ru.c:	ru->eth_params.transp_preference    = ETH_RAW_MODE;
executables/main_ru.c:	ru->if_south                        = LOCAL_RF;
executables/main_ru.c:	ru->function                        = NGFI_RRU_IF4p5;
executables/main_ru.c:	ru->eth_params.transp_preference    = ETH_UDP_IF4p5_MODE;
executables/main_ru.c:	ru->if_south                        = LOCAL_RF;
executables/main_ru.c:	ru->function                        = NGFI_RRU_IF4p5;
executables/main_ru.c:	ru->eth_params.transp_preference    = ETH_RAW_IF4p5_MODE;
executables/main_ru.c:      if (strcmp(*(RUParamList.paramarray[j][RU_IS_SLAVE_IDX].strptr), "yes") == 0) ru->is_slave=1;
executables/main_ru.c:      else ru->is_slave=0;
executables/main_ru.c:      if (strcmp(*(RUParamList.paramarray[j][RU_OTA_SYNC_ENABLE_IDX].strptr), "yes") == 0) ru->ota_sync_enable=1;
executables/main_ru.c:      else ru->ota_sync_enable=0;
executables/main_ru.c:    ru->max_pdschReferenceSignalPower     = *(RUParamList.paramarray[j][RU_MAX_RS_EPRE_IDX].uptr);;
executables/main_ru.c:    ru->max_rxgain                        = *(RUParamList.paramarray[j][RU_MAX_RXGAIN_IDX].uptr);
executables/main_ru.c:    ru->num_bands                         = RUParamList.paramarray[j][RU_BAND_LIST_IDX].numelt;
executables/main_ru.c:    ru->sf_extension                      = *(RUParamList.paramarray[j][RU_SF_EXTENSION_IDX].uptr);
executables/main_ru.c:    for (int i=0; i<ru->num_bands; i++) ru->band[i] = RUParamList.paramarray[j][RU_BAND_LIST_IDX].iptr[i];
executables/main_ru.c:    ru->eth_params.local_if_name      = strdup(*(RUParamList.paramarray[j][RU_LOCAL_IF_NAME_IDX].strptr));
executables/main_ru.c:    ru->eth_params.my_addr            = strdup(*(RUParamList.paramarray[j][RU_LOCAL_ADDRESS_IDX].strptr));
executables/main_ru.c:    ru->eth_params.remote_addr        = strdup(*(RUParamList.paramarray[j][RU_REMOTE_ADDRESS_IDX].strptr));
executables/main_ru.c:    ru->eth_params.my_portc           = *(RUParamList.paramarray[j][RU_LOCAL_PORTC_IDX].uptr);
executables/main_ru.c:    ru->eth_params.remote_portc       = *(RUParamList.paramarray[j][RU_REMOTE_PORTC_IDX].uptr);
executables/main_ru.c:    ru->eth_params.my_portd           = *(RUParamList.paramarray[j][RU_LOCAL_PORTD_IDX].uptr);
executables/main_ru.c:    ru->eth_params.remote_portd       = *(RUParamList.paramarray[j][RU_REMOTE_PORTD_IDX].uptr);
executables/main_ru.c:      ru->if_south                     = REMOTE_IF5;
executables/main_ru.c:      ru->function                     = NGFI_RAU_IF5;
executables/main_ru.c:      ru->eth_params.transp_preference = ETH_UDP_MODE;
executables/main_ru.c:      ru->if_south                     = REMOTE_IF5;
executables/main_ru.c:      ru->function                     = NGFI_RAU_IF5;
executables/main_ru.c:      ru->eth_params.transp_preference = ETH_RAW_MODE;
executables/main_ru.c:      ru->if_south                     = REMOTE_IF4p5;
executables/main_ru.c:      ru->function                     = NGFI_RAU_IF4p5;
executables/main_ru.c:      ru->eth_params.transp_preference = ETH_UDP_IF4p5_MODE;
executables/main_ru.c:      ru->if_south                     = REMOTE_IF4p5;
executables/main_ru.c:      ru->function                     = NGFI_RAU_IF4p5;
executables/main_ru.c:      ru->eth_params.transp_preference = ETH_RAW_IF4p5_MODE;
executables/main_ru.c:    if (strcmp(*(RUParamList.paramarray[j][RU_IS_SLAVE_IDX].strptr), "yes") == 0) ru->is_slave=1;
executables/main_ru.c:    else ru->is_slave=0;
executables/main_ru.c:  ru->nb_tx                             = *(RUParamList.paramarray[j][RU_NB_TX_IDX].uptr);
executables/main_ru.c:  ru->nb_rx                             = *(RUParamList.paramarray[j][RU_NB_RX_IDX].uptr);
executables/main_ru.c:  ru->att_tx                            = *(RUParamList.paramarray[j][RU_ATT_TX_IDX].uptr);
executables/main_ru.c:  ru->att_rx                            = *(RUParamList.paramarray[j][RU_ATT_RX_IDX].uptr);
executables/main_ru.c:  ru->rf_map.card=0;
executables/main_ru.c:  ru->rf_map.chain=(get_softmodem_params()->chain_offset);
executables/main_ru.c:  LOG_I(PHY, "Initializing RRU descriptor : (%s,%s,%d)\n", ru_if_types[ru->if_south], NB_timing[ru->if_timing], ru->function);
executables/main_ru.c:  LOG_I(PHY, "Starting ru_thread , is_slave %d, send_dmrs %d\n", ru->is_slave, ru->generate_dmrs_sync);
executables/main_ru.c:  if (ru->rfdevice.trx_end_func) {
executables/main_ru.c:    ru->rfdevice.trx_end_func(&ru->rfdevice);
executables/main_ru.c:    ru->rfdevice.trx_end_func = NULL;
executables/main_ru.c:  if (ru->ifdevice.trx_end_func) {
executables/main_ru.c:    ru->ifdevice.trx_end_func(&ru->ifdevice);
executables/main_ru.c:    ru->ifdevice.trx_end_func = NULL;
openair1/SCHED_NR/nr_ru_procedures.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
openair1/SCHED_NR/nr_ru_procedures.c:    start_meas(&ru->ofdm_mod_stats);
openair1/SCHED_NR/nr_ru_procedures.c:        ru->proc.frame_tx,
openair1/SCHED_NR/nr_ru_procedures.c:        ru->proc.tti_tx,
openair1/SCHED_NR/nr_ru_procedures.c:    PHY_ofdm_mod(&ru->common.txdataF_BF[aa][slot_offsetF],
openair1/SCHED_NR/nr_ru_procedures.c:                 (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED_NR/nr_ru_procedures.c:        PHY_ofdm_mod(&ru->common.txdataF_BF[aa][slot_offsetF],
openair1/SCHED_NR/nr_ru_procedures.c:                     (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED_NR/nr_ru_procedures.c:        PHY_ofdm_mod(&ru->common.txdataF_BF[aa][slot_offsetF+fp->ofdm_symbol_size],
openair1/SCHED_NR/nr_ru_procedures.c:                     (int*)&ru->common.txdata[aa][slot_offset+fp->nb_prefix_samples0+fp->ofdm_symbol_size],
openair1/SCHED_NR/nr_ru_procedures.c:        PHY_ofdm_mod(&ru->common.txdataF_BF[aa][slot_offsetF],
openair1/SCHED_NR/nr_ru_procedures.c:                     (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED_NR/nr_ru_procedures.c:          PHY_ofdm_mod(&ru->common.txdataF_BF[aa][slot_offsetF],
openair1/SCHED_NR/nr_ru_procedures.c:                       (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED_NR/nr_ru_procedures.c:          PHY_ofdm_mod(&ru->common.txdataF_BF[aa][slot_offsetF],
openair1/SCHED_NR/nr_ru_procedures.c:                       (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED_NR/nr_ru_procedures.c:    stop_meas(&ru->ofdm_mod_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  nfapi_nr_config_request_scf_t *cfg = &ru->gNB_list[0]->gNB_config;
openair1/SCHED_NR/nr_ru_procedures.c:  NR_DL_FRAME_PARMS *fp=ru->nr_frame_parms;
openair1/SCHED_NR/nr_ru_procedures.c:  int *txdata = &ru->common.txdata[aa][fp->get_samples_slot_timestamp(slot,fp,0)];
openair1/SCHED_NR/nr_ru_procedures.c:  slot,fp))),dB_fixed(signal_energy_nodc((c16_t*)ru->common.txdataF_BF[aa],2*slot_sizeF)));
openair1/SCHED_NR/nr_ru_procedures.c:  PHY_VARS_gNB **gNB_list = ru->gNB_list,*gNB;
openair1/SCHED_NR/nr_ru_procedures.c:  NR_DL_FRAME_PARMS *fp   = ru->nr_frame_parms;
openair1/SCHED_NR/nr_ru_procedures.c:  nfapi_nr_config_request_scf_t *cfg = &ru->gNB_list[0]->gNB_config;
openair1/SCHED_NR/nr_ru_procedures.c:  start_meas(&ru->precoding_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  AssertFatal(ru->nb_log_antennas > 0, "ru->nb_log_antennas is 0!\n");
openair1/SCHED_NR/nr_ru_procedures.c:  if (ru->num_gNB == 1) {
openair1/SCHED_NR/nr_ru_procedures.c:    if (ru->config.dbt_config.num_dig_beams != 0) {
openair1/SCHED_NR/nr_ru_procedures.c:         memcpy((void*) &ru->common.beam_id[i][slot_tx * fp->symbols_per_slot],
openair1/SCHED_NR/nr_ru_procedures.c:    if (ru->config.dbt_config.num_dig_beams == 0 || gNB->common_vars.analog_bf) {
openair1/SCHED_NR/nr_ru_procedures.c:      for (int i = 0; i < ru->nb_log_antennas; ++i) {
openair1/SCHED_NR/nr_ru_procedures.c:        memcpy(ru->common.txdataF_BF[i], &gNB->common_vars.txdataF[0][i][txdataF_offset], fp->samples_per_slot_wCP * sizeof(int32_t));
openair1/SCHED_NR/nr_ru_procedures.c:      for(int i = 0; i < ru->nb_log_antennas; ++i) {
openair1/SCHED_NR/nr_ru_procedures.c:        memcpy(ru->common.txdataF[i], &gNB->common_vars.txdataF[0][i][txdataF_offset], fp->samples_per_slot_wCP * sizeof(int32_t));
openair1/SCHED_NR/nr_ru_procedures.c:        for (int aa = 0; aa < ru->nb_tx; aa++) {
openair1/SCHED_NR/nr_ru_procedures.c:          nr_beam_precoding((c16_t **)ru->common.txdataF,
openair1/SCHED_NR/nr_ru_procedures.c:                            (c16_t **)ru->common.txdataF_BF,
openair1/SCHED_NR/nr_ru_procedures.c:                            ru->beam_weights[0],
openair1/SCHED_NR/nr_ru_procedures.c:                            ru->nb_log_antennas,
openair1/SCHED_NR/nr_ru_procedures.c:  stop_meas(&ru->precoding_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
openair1/SCHED_NR/nr_ru_procedures.c:    start_meas(&ru->precoding_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  if (ru->config.dbt_config.num_dig_beams != 0) {
openair1/SCHED_NR/nr_ru_procedures.c:     for(int i = 0; i < ru->gNB_list[0]->common_vars.num_beams_period; i++) {
openair1/SCHED_NR/nr_ru_procedures.c:       memcpy(&ru->common.beam_id[i][slot * fp->symbols_per_slot],
openair1/SCHED_NR/nr_ru_procedures.c:              &ru->gNB_list[0]->common_vars.beam_id[i][slot * fp->symbols_per_slot],
openair1/SCHED_NR/nr_ru_procedures.c:  if (ru->config.dbt_config.num_dig_beams == 0 || ru->gNB_list[0]->common_vars.analog_bf)
openair1/SCHED_NR/nr_ru_procedures.c:     memcpy((void*)&ru->common.txdataF_BF[aa][txdataF_BF_offset],
openair1/SCHED_NR/nr_ru_procedures.c:            (void*)&ru->gNB_list[0]->common_vars.txdataF[0][aa][txdataF_offset], // TODO hardcoded beam to 0, still need to understand how to handle this properly
openair1/SCHED_NR/nr_ru_procedures.c:       nr_beam_precoding((c16_t **)ru->gNB_list[0]->common_vars.txdataF,
openair1/SCHED_NR/nr_ru_procedures.c:                         (c16_t **)ru->common.txdataF_BF,
openair1/SCHED_NR/nr_ru_procedures.c:                         ru->beam_weights[0],
openair1/SCHED_NR/nr_ru_procedures.c:                         ru->nb_log_antennas,
openair1/SCHED_NR/nr_ru_procedures.c:    stop_meas(&ru->precoding_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  nfapi_nr_config_request_scf_t *cfg = &ru->gNB_list[0]->gNB_config;
openair1/SCHED_NR/nr_ru_procedures.c:  if (ru->idx == 0)
openair1/SCHED_NR/nr_ru_procedures.c:  start_meas(&ru->ofdm_total_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  size_t const sz = ru->nb_tx + (ru->half_slot_parallelization > 0) * ru->nb_tx;
openair1/SCHED_NR/nr_ru_procedures.c:  for (int aid = 0; aid < ru->nb_tx; aid++) {
openair1/SCHED_NR/nr_ru_procedures.c:        (ru->half_slot_parallelization > 0) ? ru->nr_frame_parms->symbols_per_slot >> 1 : ru->nr_frame_parms->symbols_per_slot;
openair1/SCHED_NR/nr_ru_procedures.c:    pushTpool(ru->threadPool, t);
openair1/SCHED_NR/nr_ru_procedures.c:    if (ru->half_slot_parallelization > 0) {
openair1/SCHED_NR/nr_ru_procedures.c:      feptx_cmd->startSymbol = ru->nr_frame_parms->symbols_per_slot >> 1;
openair1/SCHED_NR/nr_ru_procedures.c:      feptx_cmd->numSymbols = ru->nr_frame_parms->symbols_per_slot >> 1;
openair1/SCHED_NR/nr_ru_procedures.c:      pushTpool(ru->threadPool, t);
openair1/SCHED_NR/nr_ru_procedures.c:  stop_meas(&ru->ofdm_total_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  if (ru->idx == 0)
openair1/SCHED_NR/nr_ru_procedures.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
openair1/SCHED_NR/nr_ru_procedures.c:  LOG_D(PHY,"aid %d, frame %d slot %d, startSymbol %d, endSymbol %d\n", aid, ru->proc.frame_rx, tti_rx, startSymbol, endSymbol);
openair1/SCHED_NR/nr_ru_procedures.c:                     ru->common.rxdata[aid],
openair1/SCHED_NR/nr_ru_procedures.c:                     &ru->common.rxdataF[aid][offset],
openair1/SCHED_NR/nr_ru_procedures.c:                     ru->N_TA_offset);
openair1/SCHED_NR/nr_ru_procedures.c:  if (ru->idx == 0) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPRX, 1 );
openair1/SCHED_NR/nr_ru_procedures.c:  start_meas(&ru->ofdm_demod_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  size_t const sz = ru->nb_rx + (ru->half_slot_parallelization > 0) * ru->nb_rx;
openair1/SCHED_NR/nr_ru_procedures.c:  for (int aid=0;aid<ru->nb_rx;aid++) {
openair1/SCHED_NR/nr_ru_procedures.c:    feprx_cmd->slot = ru->proc.tti_rx;
openair1/SCHED_NR/nr_ru_procedures.c:    feprx_cmd->endSymbol = (ru->half_slot_parallelization > 0) ? (ru->nr_frame_parms->symbols_per_slot >> 1) - 1
openair1/SCHED_NR/nr_ru_procedures.c:                                                               : (ru->nr_frame_parms->symbols_per_slot - 1);
openair1/SCHED_NR/nr_ru_procedures.c:    pushTpool(ru->threadPool, t);
openair1/SCHED_NR/nr_ru_procedures.c:    if (ru->half_slot_parallelization > 0) {
openair1/SCHED_NR/nr_ru_procedures.c:      feprx_cmd->slot = ru->proc.tti_rx;
openair1/SCHED_NR/nr_ru_procedures.c:      feprx_cmd->startSymbol = ru->nr_frame_parms->symbols_per_slot >> 1;
openair1/SCHED_NR/nr_ru_procedures.c:      feprx_cmd->endSymbol = ru->nr_frame_parms->symbols_per_slot - 1;
openair1/SCHED_NR/nr_ru_procedures.c:      pushTpool(ru->threadPool, t);
openair1/SCHED_NR/nr_ru_procedures.c:  stop_meas(&ru->ofdm_demod_stats);
openair1/SCHED_NR/nr_ru_procedures.c:  if (ru->idx == 0) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPRX, 0 );
executables/lte-enb.c:    //      memcpy(&pre_scd_eNB_UE_stats,&RC.mac[ru->eNB_list[0]->Mod_id]->UE_info.eNB_UE_stats, sizeof(eNB_UE_STATS)*MAX_NUM_CCs*NUMBER_OF_UE_MAX);
executables/lte-enb.c:    //      memcpy(&pre_scd_activeUE, &RC.mac[ru->eNB_list[0]->Mod_id]->UE_info.active, sizeof(bool)*NUMBER_OF_UE_MAX);
executables/lte-enb.c:    AssertFatal((ret= pthread_mutex_lock(&ru->proc.mutex_pre_scd))==0,"[eNB] error locking proc mutex for eNB pre scd, return %d\n",ret);
executables/lte-enb.c:    ru->proc.instance_pre_scd++;
executables/lte-enb.c:    if (ru->proc.instance_pre_scd == 0) {
executables/lte-enb.c:      if (pthread_cond_signal(&ru->proc.cond_pre_scd) != 0) {
executables/lte-enb.c:             proc->frame_rx,proc->subframe_rx,ru->proc.instance_pre_scd );
executables/lte-enb.c:    AssertFatal((ret= pthread_mutex_unlock(&ru->proc.mutex_pre_scd))==0,"[eNB] error unlocking proc mutex for eNB pre scd, return %d\n",ret);
executables/lte-enb.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-enb.c:  RU_proc_t *ru_proc     = &ru->proc;
executables/lte-enb.c:    L1_proc->timestamp_tx = ru_proc->timestamp_rx + (ru->sf_ahead*fp->samples_per_tti);
executables/lte-enb.c:    L1_proc->frame_tx     = (L1_proc->subframe_rx > (9-ru->sf_ahead)) ? (L1_proc->frame_rx+1)&1023 : L1_proc->frame_rx;
executables/lte-enb.c:    L1_proc->subframe_tx  = (L1_proc->subframe_rx + ru->sf_ahead)%10;
executables/lte-enb.c:    ru_proc = &ru->proc;
executables/lte-enb.c:    fp      = ru->frame_parms;
executables/lte-enb.c:  RU_proc_t *ru_proc=&ru->proc;
executables/lte-enb.c:  L1_proc->timestamp_tx = ru_proc->timestamp_rx + (ru->sf_ahead*fp->samples_per_tti);
executables/lte-enb.c:  L1_proc->frame_tx     = (L1_proc->subframe_rx > (9-ru->sf_ahead)) ? (L1_proc->frame_rx+1)&1023 : L1_proc->frame_rx;
executables/lte-enb.c:  L1_proc->subframe_tx  = (L1_proc->subframe_rx + ru->sf_ahead)%10;
executables/lte-enb.c:  LOG_D(PHY,"wakeup_rxtx: L1_proc->subframe_rx %d, L1_proc->subframe_tx %d, RU %d\n",L1_proc->subframe_rx,L1_proc->subframe_tx,ru->idx);
executables/lte-enb.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_WAKEUP_RXTX_RX_RU+ru->idx, L1_proc->frame_rx);
executables/lte-enb.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_WAKEUP_RXTX_RX_RU+ru->idx, L1_proc->subframe_rx);
executables/lte-enb.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_WAKEUP_RXTX_TX_RU+ru->idx, L1_proc->frame_tx);
executables/lte-enb.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_WAKEUP_RXTX_TX_RU+ru->idx, L1_proc->subframe_tx);
executables/lte-enb.c:                eNB->Mod_id,frame,subframe,ru->idx,eNB->num_RU,proc->RU_mask_prach_br);
openair1/SCHED_NR/phy_procedures_nr_gNB.c:      slot_offset -= ru->N_TA_offset;
openair1/SCHED_NR/phy_procedures_nr_gNB.c:             &ru->common.rxdata[0][slot_offset],
openair1/SCHED_NR/nr_prach_procedures.c:      for (ru_aa=0,aa=0;ru_aa<ru->nb_rx;ru_aa++,aa++) {
openair1/SCHED_NR/nr_prach_procedures.c:        gNB->prach_vars.rxsigF[aa] = ru->prach_rxsigF[prach_oc][ru_aa];
executables/nr-softmodem.c:  if (ru->rfdevice.trx_stop_func) {
executables/nr-softmodem.c:    ru->rfdevice.trx_stop_func(&ru->rfdevice);
executables/nr-softmodem.c:  if (ru->ifdevice.trx_stop_func) {
executables/nr-softmodem.c:    ru->ifdevice.trx_stop_func(&ru->ifdevice);
executables/ru_control.c:  LOG_I(PHY,"Sending RAU tick to RRU %d\n",ru->idx);
executables/ru_control.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:	      "RU %d cannot access remote radio\n",ru->idx);
executables/ru_control.c:    ru->idx,
executables/ru_control.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:	      "RU %d failed send configuration to remote radio\n",ru->idx);
executables/ru_control.c:	(int)rru_config_msg.len,ru->num_bands,ru->max_pdschReferenceSignalPower,ru->max_rxgain,ru->nb_tx,ru->nb_rx);
executables/ru_control.c:  switch (ru->function) {
executables/ru_control.c:    AssertFatal(1==0,"RU_function is unknown %d\n",ru->function);
executables/ru_control.c:  cap->num_bands                                  = ru->num_bands;
executables/ru_control.c:  for (i=0;i<ru->num_bands;i++) {
executables/ru_control.c:	  ru->band[i],ru->nb_rx,ru->nb_tx,ru->max_pdschReferenceSignalPower,ru->max_rxgain);
executables/ru_control.c:    cap->band_list[i]                             = ru->band[i];
executables/ru_control.c:    cap->nb_rx[i]                                 = ru->nb_rx;
executables/ru_control.c:    cap->nb_tx[i]                                 = ru->nb_tx;
executables/ru_control.c:    cap->max_pdschReferenceSignalPower[i]         = ru->max_pdschReferenceSignalPower;
executables/ru_control.c:    cap->max_rxgain[i]                            = ru->max_rxgain;
executables/ru_control.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:	      "RU %d failed send capabilities to RAU\n",ru->idx);
executables/ru_control.c:    LOG_I(PHY,"Sending RAU tick to RRU %d\n",ru->idx);
executables/ru_control.c:    AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:		"RU %d cannot access remote radio\n",ru->idx);
executables/ru_control.c:    if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/ru_control.c:      LOG_I(PHY,"Waiting for RRU %d\n",ru->idx);     
executables/ru_control.c:      LOG_I(PHY,"Received capabilities from RRU %d (len %d/%d, num_bands %d,max_pdschReferenceSignalPower %d, max_rxgain %d, nb_tx %d, nb_rx %d)\n",ru->idx,
executables/ru_control.c:      LOG_E(PHY,"Received incorrect message %d from RRU %d\n",rru_config_msg.type,ru->idx); 
executables/ru_control.c:  LOG_I(PHY,"Sending Configuration to RRU %d (num_bands %d,band0 %d,txfreq %u,rxfreq %u,att_tx %d,att_rx %d,N_RB_DL %d,N_RB_UL %d,3/4FS %d, prach_FO %d, prach_CI %d)\n",ru->idx,
executables/ru_control.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:	      "RU %d failed send configuration to remote radio\n",ru->idx);
executables/ru_control.c:    if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/ru_control.c:	(int)rru_config_msg.len,ru->num_bands,ru->max_pdschReferenceSignalPower,ru->max_rxgain,ru->nb_tx,ru->nb_rx);
executables/ru_control.c:  switch (ru->function) {
executables/ru_control.c:    AssertFatal(1==0,"RU_function is unknown %d\n",ru->function);
executables/ru_control.c:  cap->num_bands                                  = ru->num_bands;
executables/ru_control.c:  for (i=0;i<ru->num_bands;i++) {
executables/ru_control.c:	  ru->band[i],ru->nb_rx,ru->nb_tx,ru->max_pdschReferenceSignalPower,ru->max_rxgain);
executables/ru_control.c:    cap->band_list[i]                             = ru->band[i];
executables/ru_control.c:    cap->nb_rx[i]                                 = ru->nb_rx;
executables/ru_control.c:    cap->nb_tx[i]                                 = ru->nb_tx;
executables/ru_control.c:    cap->max_pdschReferenceSignalPower[i]         = ru->max_pdschReferenceSignalPower;
executables/ru_control.c:    cap->max_rxgain[i]                            = ru->max_rxgain;
executables/ru_control.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:	      "RU %d failed send capabilities to RAU\n",ru->idx);
executables/ru_control.c:    if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/ru_control.c:  LOG_I(PHY,"RRU %d, num_bands %d, looking for band %d\n",ru->idx,cap->num_bands,ru->frame_parms->eutra_band);
executables/ru_control.c:    LOG_I(PHY,"band %d on RRU %d\n",cap->band_list[i],ru->idx);
executables/ru_control.c:    if (ru->frame_parms->eutra_band == cap->band_list[i]) {
executables/ru_control.c:    LOG_I(PHY,"Couldn't find target EUTRA band %d on RRU %d\n",ru->frame_parms->eutra_band,ru->idx);
executables/ru_control.c:  switch (ru->if_south) {
executables/ru_control.c:    LOG_I(PHY,"No compatible Fronthaul interface found for RRU %d\n", ru->idx);
executables/ru_control.c:  LOG_I(PHY, "Received capabilities from RRU %d\n",ru->idx);
executables/ru_control.c:	      "Cannot configure RRU %d, check_capabilities returned %d\n", ru->idx,ret);
executables/ru_control.c:  ru->nb_tx                      = capabilities->nb_tx[0];
executables/ru_control.c:  ru->nb_rx                      = capabilities->nb_rx[0];
executables/ru_control.c:  LOG_I(PHY, "Using %s fronthaul (%d), band %d \n",ru_if_formats[ru->if_south],ru->if_south,ru->frame_parms->eutra_band);
executables/ru_control.c:  config->FH_fmt                 = ru->if_south;
executables/ru_control.c:  config->band_list[0]           = ru->frame_parms->eutra_band;
executables/ru_control.c:  config->tx_freq[0]             = ru->frame_parms->dl_CarrierFreq;
executables/ru_control.c:  config->rx_freq[0]             = ru->frame_parms->ul_CarrierFreq;
executables/ru_control.c:  config->tdd_config[0]          = ru->frame_parms->tdd_config;
executables/ru_control.c:  config->tdd_config_S[0]        = ru->frame_parms->tdd_config_S;
executables/ru_control.c:  config->att_tx[0]              = ru->att_tx;
executables/ru_control.c:  config->att_rx[0]              = ru->att_rx;
executables/ru_control.c:  config->N_RB_DL[0]             = ru->frame_parms->N_RB_DL;
executables/ru_control.c:  config->N_RB_UL[0]             = ru->frame_parms->N_RB_UL;
executables/ru_control.c:  config->threequarter_fs[0]     = ru->frame_parms->threequarter_fs;
executables/ru_control.c:  if (ru->if_south==REMOTE_IF4p5) {
executables/ru_control.c:    config->prach_FreqOffset[0]  = ru->frame_parms->prach_config_common.prach_ConfigInfo.prach_FreqOffset;
executables/ru_control.c:    config->prach_ConfigIndex[0] = ru->frame_parms->prach_config_common.prach_ConfigInfo.prach_ConfigIndex;
executables/ru_control.c:      config->emtc_prach_CElevel_enable[0][i]  = ru->frame_parms->prach_emtc_config_common.prach_ConfigInfo.prach_CElevel_enable[i];
executables/ru_control.c:      config->emtc_prach_FreqOffset[0][i]      = ru->frame_parms->prach_emtc_config_common.prach_ConfigInfo.prach_FreqOffset[i];
executables/ru_control.c:      config->emtc_prach_ConfigIndex[0][i]     = ru->frame_parms->prach_emtc_config_common.prach_ConfigInfo.prach_ConfigIndex[i];
executables/ru_control.c:  init_frame_parms(ru->frame_parms,1);
executables/ru_control.c:  ru->frame_parms->eutra_band                                               = config->band_list[0];
executables/ru_control.c:  ru->frame_parms->dl_CarrierFreq                                           = config->tx_freq[0];
executables/ru_control.c:  ru->frame_parms->ul_CarrierFreq                                           = config->rx_freq[0];
executables/ru_control.c:  if (ru->frame_parms->dl_CarrierFreq == ru->frame_parms->ul_CarrierFreq) {
executables/ru_control.c:    ru->frame_parms->frame_type                                            = TDD;
executables/ru_control.c:    ru->frame_parms->tdd_config                                            = config->tdd_config[0];
executables/ru_control.c:    ru->frame_parms->tdd_config_S                                          = config->tdd_config_S[0];
executables/ru_control.c:  else ru->frame_parms->frame_type                                         = FDD;
executables/ru_control.c:  ru->att_tx                                                               = config->att_tx[0];
executables/ru_control.c:  ru->att_rx                                                               = config->att_rx[0];
executables/ru_control.c:  ru->frame_parms->N_RB_DL                                                  = config->N_RB_DL[0];
executables/ru_control.c:  ru->frame_parms->N_RB_UL                                                  = config->N_RB_UL[0];
executables/ru_control.c:  ru->frame_parms->threequarter_fs                                          = config->threequarter_fs[0];
executables/ru_control.c:  ru->frame_parms->pdsch_config_common.referenceSignalPower                 = ru->max_pdschReferenceSignalPower-config->att_tx[0];
executables/ru_control.c:  if (ru->function==NGFI_RRU_IF4p5) {
executables/ru_control.c:    ru->frame_parms->att_rx = ru->att_rx;
executables/ru_control.c:    ru->frame_parms->att_tx = ru->att_tx;
executables/ru_control.c:    LOG_I(PHY,"Setting ru->function to NGFI_RRU_IF4p5, prach_FrequOffset %d, prach_ConfigIndex %d, att (%d,%d)\n",
executables/ru_control.c:	  config->prach_FreqOffset[0],config->prach_ConfigIndex[0],ru->att_tx,ru->att_rx);
executables/ru_control.c:    ru->frame_parms->prach_config_common.prach_ConfigInfo.prach_FreqOffset  = config->prach_FreqOffset[0];
executables/ru_control.c:    ru->frame_parms->prach_config_common.prach_ConfigInfo.prach_ConfigIndex = config->prach_ConfigIndex[0];
executables/ru_control.c:      ru->frame_parms->prach_emtc_config_common.prach_ConfigInfo.prach_CElevel_enable[i] = config->emtc_prach_CElevel_enable[0][i];
executables/ru_control.c:      ru->frame_parms->prach_emtc_config_common.prach_ConfigInfo.prach_FreqOffset[i]     = config->emtc_prach_FreqOffset[0][i];
executables/ru_control.c:      ru->frame_parms->prach_emtc_config_common.prach_ConfigInfo.prach_ConfigIndex[i]    = config->emtc_prach_ConfigIndex[0][i];
executables/ru_control.c:  init_frame_parms(ru->frame_parms,1);
executables/ru_control.c:  fill_rf_config(ru,ru->rf_config_file);
executables/ru_control.c:  LOG_I(PHY,"Sending RAU tick to RRU %d %lu bytes\n",ru->idx,rru_config_msg.len);
executables/ru_control.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:                "RU %d cannot access remote radio\n",ru->idx);
executables/ru_control.c:  RU_proc_t          *proc    = &ru->proc;
executables/ru_control.c:  if (ru->start_if) {
executables/ru_control.c:    LOG_I(PHY,"Starting IF interface for RU %d\n",ru->idx);
executables/ru_control.c:		ru->start_if(ru,NULL) 	== 0, "Could not start the IF device\n");
executables/ru_control.c:    if (ru->if_south != LOCAL_RF) wait_eNBs();
executables/ru_control.c:  ru->state = (ru->function==eNodeB_3GPP || ru->if_south == REMOTE_IF5)? RU_RUN : RU_IDLE;
executables/ru_control.c:  LOG_I(PHY,"Control channel ON for RU %d\n", ru->idx);
executables/ru_control.c:      if (ru->state == RU_IDLE && ru->if_south != LOCAL_RF)
executables/ru_control.c:      if (ru->state == RU_RUN && ru->if_south != LOCAL_RF){
executables/ru_control.c:	LTE_DL_FRAME_PARMS *fp = &ru->eNB_list[0]->frame_parms;	
executables/ru_control.c:      if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/ru_control.c:	LOG_D(PHY,"Waiting msg for RU %d\n", ru->idx);     
executables/ru_control.c:	      if (ru->if_south != LOCAL_RF){
executables/ru_control.c:		if (send_capab(ru) == 0) ru->state = RU_CONFIG;
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF) LOG_E(PHY,"Received RRU_capab msg...Ignoring\n");
executables/ru_control.c:		LOG_I(PHY,"Received capabilities from RRU %d (len %d/%d, num_bands %d,max_pdschReferenceSignalPower %d, max_rxgain %d, nb_tx %d, nb_rx %d)\n",ru->idx,
executables/ru_control.c:		if (send_config(ru,rru_config_msg) == 0) ru->state = RU_CONFIG;
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF){
executables/ru_control.c:		ru->frame_parms = calloc(1, sizeof(*ru->frame_parms));
executables/ru_control.c:		fill_rf_config(ru,ru->rf_config_file);
executables/ru_control.c:		init_frame_parms(ru->frame_parms,1);
executables/ru_control.c:		ru->frame_parms->nb_antennas_rx = ru->nb_rx;
executables/ru_control.c:		//if (ru->is_slave == 1) lte_sync_time_init(&ru->frame_parms);
executables/ru_control.c:		if (ru->rfdevice.is_init != 1) openair0_device_load(&ru->rfdevice,&ru->openair0_cfg);
executables/ru_control.c:		if (ru->rfdevice.trx_config_func) AssertFatal((ru->rfdevice.trx_config_func(&ru->rfdevice,&ru->openair0_cfg)==0), 
executables/ru_control.c:							      "Failed to configure RF device for RU %d\n",ru->idx);
executables/ru_control.c:		LOG_I(PHY,"Sending CONFIG_OK to RAU %d\n", ru->idx);
executables/ru_control.c:		AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/ru_control.c:			    "RU %d failed send CONFIG_OK to RAU\n",ru->idx);
executables/ru_control.c:		ru->state = RU_READY;
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF) LOG_E(PHY,"Received RRU_config_ok msg...Ignoring\n");
executables/ru_control.c:		ru->state = (ru->is_slave == 1) ? RU_SYNC : RU_RUN ;
executables/ru_control.c:		ru->in_synch = 0;
executables/ru_control.c:		LOG_I(PHY, "Signaling main thread that RU %d (is_slave %d) is ready in state %s\n",ru->idx,ru->is_slave,ru_states[ru->state]);
executables/ru_control.c:		pthread_mutex_lock(ru->ru_mutex);
executables/ru_control.c:		*ru->ru_mask &= ~(1<<ru->idx);
executables/ru_control.c:		pthread_cond_signal(ru->ru_cond);
executables/ru_control.c:		pthread_mutex_unlock(ru->ru_mutex);
executables/ru_control.c:		LOG_I(PHY,"Sending Start to RRU %d\n", ru->idx);
executables/ru_control.c:		AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),"Failed to send msg to RU %d\n",ru->idx);
executables/ru_control.c:		  LOG_E( PHY, "ERROR pthread_cond_signal for RU %d\n",ru->idx);
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF){
executables/ru_control.c:	        ru->frame_parms->num_MBSFN_config = ((RRU_config_t *)&rru_config_msg.msg[0])->num_MBSFN_config;
executables/ru_control.c:		 ru->frame_parms->MBSFN_config[i].mbsfn_SubframeConfig=((RRU_config_t *)&rru_config_msg.msg[0])->MBSFN_config[i].mbsfn_SubframeConfig;
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF) LOG_E(PHY,"Received RRU_config_update_ok msg...Ignoring\n");
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF){
executables/ru_control.c:		if (ru->state == RU_READY){
executables/ru_control.c:		  LOG_I(PHY, "Signaling main thread that RU %d is ready\n",ru->idx);
executables/ru_control.c:		  pthread_mutex_lock(ru->ru_mutex);
executables/ru_control.c:		  *ru->ru_mask &= ~(1<<ru->idx);
executables/ru_control.c:		  pthread_cond_signal(ru->ru_cond);
executables/ru_control.c:		  pthread_mutex_unlock(ru->ru_mutex);
executables/ru_control.c:		  ru->state = (ru->is_slave == 1) ? RU_SYNC : RU_RUN ;
executables/ru_control.c:	          ru->cmd   = EMPTY;			
executables/ru_control.c:		    LOG_E( PHY, "ERROR pthread_cond_signal for RU %d\n",ru->idx);
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF) LOG_E(PHY,"Received RRU_sync_ok msg...Ignoring\n");
executables/ru_control.c:		if (ru->is_slave == 1){
executables/ru_control.c:                  printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Received RRU_sync_ok from RRU %d\n",ru->idx);
executables/ru_control.c:		  ru->state = RU_RUN;		
executables/ru_control.c:              if (ru->if_south != LOCAL_RF) LOG_E(PHY,"Received RRU frame resynch message, should not happen in RAU\n");
executables/ru_control.c:		ru->cmd = RU_FRAME_RESYNCH;
executables/ru_control.c:		ru->cmdval = ((uint16_t*)&rru_config_msg.msg[0])[0];
executables/ru_control.c:		LOG_I(PHY,"Received Frame Resynch message with value %d\n",ru->cmdval);
executables/ru_control.c:	      if (ru->if_south == LOCAL_RF){
executables/ru_control.c:		if (ru->state == RU_RUN || ru->state == RU_ERROR){
executables/ru_control.c:		  ru->state = RU_READY;
executables/ru_control.c:	      if (ru->if_south != LOCAL_RF){
executables/ru_control.c:		if (ru->state == RU_IDLE){
executables/lte-ru.c:  if (ru->idx == 0) VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TST, ru->proc.timestamp_tx&0xffffffff );
executables/lte-ru.c:  ru->south_out_cnt++;
executables/lte-ru.c:  int offset = subframe*ru->frame_parms->samples_per_tti;
executables/lte-ru.c:  void *buffs[ru->nb_tx]; 
executables/lte-ru.c:  for (int aid=0;aid<ru->nb_tx;aid++) buffs[aid] = (void*)&ru->common.txdata[aid][offset]; 
executables/lte-ru.c:  ru->ifdevice.trx_write_func2(&ru->ifdevice,
executables/lte-ru.c:			       ru->frame_parms->samples_per_tti,
executables/lte-ru.c:			       ru->nb_tx); 
executables/lte-ru.c:  if (ru->idx == 0) VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TST, ru->proc.timestamp_tx&0xffffffff );
executables/lte-ru.c:  LOG_D(PHY,"ENTERED fh_if4p5_south_out   Sending IF4p5 for frame %d subframe %d ru %d\n",ru->proc.frame_tx,ru->proc.tti_tx,ru->idx);
executables/lte-ru.c:  if (subframe_select(ru->frame_parms, subframe)!=SF_UL) {
executables/lte-ru.c:    ru->south_out_cnt++;
executables/lte-ru.c:    LOG_D(PHY,"south_out_cnt %d\n",ru->south_out_cnt);
executables/lte-ru.c:  /*if (ru->idx == 0 || ru->idx == ru) {
executables/lte-ru.c:      VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_TX0_RU+ru->idx, ru->proc.frame_tx );
executables/lte-ru.c:      VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_TX0_RU+ru->idx, ru->proc.subframe_tx );
executables/lte-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_IF4P5_SOUTH_OUT_RU+ru->idx, ru->proc.frame_tx);
executables/lte-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_IF4P5_SOUTH_OUT_RU+ru->idx, ru->proc.tti_tx);
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  RU_proc_t *proc = &ru->proc;
executables/lte-ru.c:  ru->ifdevice.trx_read_func2(&ru->ifdevice,&proc->timestamp_rx,NULL,fp->samples_per_tti);
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  RU_proc_t *proc = &ru->proc;
executables/lte-ru.c:  LOG_D(PHY,"fh_if4p5_south_in: RU %d, frame %d, subframe %d, ru %d, mask %x\n",ru->idx,*frame,*subframe,ru->idx,proc->symbol_mask[*subframe]);
executables/lte-ru.c:      LOG_D(PHY,"fh_if4p5_south_in (%s/%d): RU %d, frame %d, subframe %d, f %d, sf %d, symbol %d\n",packet_type == IF4p5_PULFFT ? "PULFFT" : "PULTICK",packet_type,ru->idx,*frame,*subframe,f,sf,symbol_number);
executables/lte-ru.c:      if (oai_exit == 1 || ru->cmd== STOP_RU) break;
executables/lte-ru.c:                 if ((proc->first_rx==0) && (f!=*frame)) LOG_E(PHY,"rx_fh_if4p5: PULTICK received frame %d != expected %d (RU %d) \n",f,*frame, ru->idx);
executables/lte-ru.c:      LOG_D(PHY,"rx_fh_if4p5 for RU %d: subframe %d, sf %d, symbol %d, symbol mask %x\n",ru->idx,*subframe,sf,symbol_number,proc->symbol_mask[sf]);
executables/lte-ru.c:    proc->tti_tx   = (sf+ru->sf_ahead)%10;
executables/lte-ru.c:    proc->frame_tx = (sf>(9-ru->sf_ahead)) ? (f+1)&1023 : f;
executables/lte-ru.c:    if (ru->cmd != WAIT_RESYNCH && proc->frame_rx != *frame) {
executables/lte-ru.c:    } else if (ru->cmd == WAIT_RESYNCH && proc->frame_rx != *frame) {
executables/lte-ru.c:      ru->cmd=EMPTY;
executables/lte-ru.c:  /*if (ru->idx == 0 || ru->idx == 1) {
executables/lte-ru.c:    VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_RX0_RU+ru->idx, f );
executables/lte-ru.c:    VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_RX0_RU+ru->idx, sf );
executables/lte-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_IF4P5_SOUTH_IN_RU+ru->idx,f);
executables/lte-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_IF4P5_SOUTH_IN_RU+ru->idx,sf);
executables/lte-ru.c:  LOG_D(PHY,"RU %d: fh_if4p5_south_in returning ...\n",ru->idx);
executables/lte-ru.c:  RU_proc_t *proc=&ru->proc;
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  RU_proc_t *proc        = &ru->proc;
executables/lte-ru.c:    if (ru->cmd == STOP_RU) break;
executables/lte-ru.c:  symbol_mask_full = (1<<ru->frame_parms->symbols_per_tti)-1;
executables/lte-ru.c:  ru->north_in_cnt++;
executables/lte-ru.c:  if (ru->idx == 0) {
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  RU_proc_t *proc        = &ru->proc;
executables/lte-ru.c:  ru->north_in_cnt++;
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  RU_proc_t *proc        = &ru->proc;
executables/lte-ru.c:  LOG_D(PHY,"fh_if4p5_north_asynch_in: RU %d, frame %d, subframe %d\n", ru->idx, *frame, *subframe);
executables/lte-ru.c:    if (ru->cmd == STOP_RU) {
executables/lte-ru.c:      ru->cmd=STOP_RU;
executables/lte-ru.c:    if ((subframe_select(fp,tti_tx) == SF_DL) && (symbol_number == 0)) start_meas(&ru->rx_fhaul);
executables/lte-ru.c:  if (subframe_select(fp,tti_tx) == SF_DL) stop_meas(&ru->rx_fhaul);
executables/lte-ru.c:  ru->north_in_cnt++;
executables/lte-ru.c:  LOG_D(PHY,"RU %d/%d TST %llu, frame %d, subframe %d\n",ru->idx,0,(long long unsigned int)proc->timestamp_tx,frame_tx,tti_tx);
executables/lte-ru.c:  if (ru->idx == 0) {
executables/lte-ru.c:  if (ru->feptx_ofdm) ru->feptx_ofdm(ru, frame_tx, tti_tx);
executables/lte-ru.c:  if (ru->fh_south_out) ru->fh_south_out(ru, frame_tx, tti_tx, proc->timestamp_tx);
executables/lte-ru.c:  RU_proc_t *proc        = &ru->proc;
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  if (ru->idx==0) {
executables/lte-ru.c:    ru->north_out_cnt++;
executables/lte-ru.c:  start_meas(&ru->tx_fhaul);
executables/lte-ru.c:  ru->north_out_cnt++;
executables/lte-ru.c:  stop_meas(&ru->tx_fhaul);
executables/lte-ru.c:  RU_proc_t *proc = &ru->proc;
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  void *rxp[ru->nb_rx];
executables/lte-ru.c:  for (i=0; i<ru->nb_rx; i++)
executables/lte-ru.c:    rxp[i] = (void *)&ru->common.rxdata[i][*subframe*fp->samples_per_tti];
executables/lte-ru.c:  if(ru->emulate_rf) {
executables/lte-ru.c:    rxs = ru->rfdevice.trx_read_func(&ru->rfdevice,
executables/lte-ru.c:                                     ru->nb_rx);
executables/lte-ru.c:  ru->south_in_cnt++;
executables/lte-ru.c:  LOG_D(PHY,"south_in_cnt %d\n",ru->south_in_cnt);
executables/lte-ru.c:  if (ru->cmd==RU_FRAME_RESYNCH) {
executables/lte-ru.c:    LOG_I(PHY,"Applying frame resynch %d => %d\n",*frame,ru->cmdval);
executables/lte-ru.c:    if (proc->frame_rx>ru->cmdval) ru->ts_offset += (proc->frame_rx - ru->cmdval)*fp->samples_per_tti*10;
executables/lte-ru.c:    else ru->ts_offset -= (-proc->frame_rx + ru->cmdval)*fp->samples_per_tti*10;
executables/lte-ru.c:    *frame = ru->cmdval;
executables/lte-ru.c:    ru->cmd=EMPTY;
executables/lte-ru.c:    proc->timestamp_rx = ts-ru->ts_offset;
executables/lte-ru.c:    ru->ts_offset = proc->timestamp_rx;
executables/lte-ru.c:    LOG_D(PHY,"rx_rf: rfdevice timing drift of %"PRId64" samples (ts_off %"PRId64")\n",proc->timestamp_rx - old_ts - fp->samples_per_tti,ru->ts_offset);
executables/lte-ru.c:    ru->ts_offset += (proc->timestamp_rx - old_ts - fp->samples_per_tti);
executables/lte-ru.c:    proc->timestamp_rx = ts-ru->ts_offset;
executables/lte-ru.c:  if (get_thread_parallel_conf() == PARALLEL_SINGLE_THREAD && ru->fh_north_asynch_in == NULL) {
executables/lte-ru.c:    proc->timestamp_phy_tx = proc->timestamp_rx+((ru->sf_ahead-1)*fp->samples_per_tti);
executables/lte-ru.c:    proc->subframe_phy_tx  = (proc->tti_rx+(ru->sf_ahead-1))%10;
executables/lte-ru.c:    proc->frame_phy_tx     = (proc->tti_rx>(9-(ru->sf_ahead-1))) ? (proc->frame_rx+1)&1023 : proc->frame_rx;
executables/lte-ru.c:    proc->timestamp_tx = proc->timestamp_rx+(ru->sf_ahead*fp->samples_per_tti);
executables/lte-ru.c:    proc->tti_tx       = (proc->tti_rx+ru->sf_ahead)%10;
executables/lte-ru.c:    proc->frame_tx     = (proc->tti_rx>(9-ru->sf_ahead)) ? (proc->frame_rx+1)&1023 : proc->frame_rx;
executables/lte-ru.c:          ru->idx,
executables/lte-ru.c:          (int)ru->ts_offset,
executables/lte-ru.c:          ru->idx,
executables/lte-ru.c:          (int)ru->ts_offset,
executables/lte-ru.c:  if (ru->idx == 0) {
executables/lte-ru.c:  //LOG_I(PHY,"timestamp_rx %lu, frame %d(%d), subframe %d(%d)\n",ru->timestamp_rx,proc->frame_rx,frame,proc->tti_rx,subframe);
executables/lte-ru.c:  RU_proc_t *proc = &ru->proc;
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  void *txp[ru->nb_tx];
executables/lte-ru.c:    T_INT(0), T_BUFFER(&ru->common.txdata[0][subframe * fp->samples_per_tti], fp->samples_per_tti * 4));
executables/lte-ru.c:      int txsymb = fp->dl_symbols_in_S_subframe+(ru->is_slave==0 ? 1 : 0);
executables/lte-ru.c:               + ru->end_of_burst_delay;
executables/lte-ru.c:      sf_extension = ru->sf_extension;
executables/lte-ru.c:    for (i=0; i<ru->nb_tx; i++)
executables/lte-ru.c:      txp[i] = (void *)&ru->common.txdata[i][(subframe*fp->samples_per_tti)-sf_extension];
executables/lte-ru.c:          LOG_D(PHY,"[TXPATH] RU %d late_control %d not implemented\n",ru->idx, late_control);
executables/lte-ru.c:    VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TST, (timestamp-ru->openair0_cfg.tx_sample_advance)&0xffffffff );
executables/lte-ru.c:   txs = ru->rfdevice
executables/lte-ru.c:             .trx_write_func(&ru->rfdevice, timestamp + ru->ts_offset - sf_extension, txp, siglen + sf_extension, ru->nb_tx, flags);
executables/lte-ru.c:   ru->south_out_cnt++;
executables/lte-ru.c:   LOG_D(PHY, "south_out_cnt %d\n", ru->south_out_cnt);
executables/lte-ru.c:           ru->idx,
executables/lte-ru.c:    void *dummy_tx[ru->frame_parms->nb_antennas_tx];
executables/lte-ru.c:    int16_t dummy_tx_data[ru->frame_parms->nb_antennas_tx][2]; // 2 because the function we call use pairs of int16_t implicitly as complex numbers
executables/lte-ru.c:    for (int i=0; i<ru->frame_parms->nb_antennas_tx; i++)
executables/lte-ru.c:                    == ru->rfdevice.trx_write_func(&ru->rfdevice,
executables/lte-ru.c:                                                   timestamp + ru->ts_offset - sf_extension,
executables/lte-ru.c:                                                   ru->frame_parms->nb_antennas_tx,
executables/lte-ru.c:  RU_proc_t *proc  = &ru->proc;
executables/lte-ru.c:    if (ru->state != RU_RUN) {
executables/lte-ru.c:      if (ru->fh_north_asynch_in) {
executables/lte-ru.c:        if (subframe_select(ru->frame_parms,subframe)!=SF_UL)
executables/lte-ru.c:          ru->fh_north_asynch_in(ru, &frame, &subframe);
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_timedlock(&slave_proc->mutex_FH,&wait))==0,"ERROR pthread_mutex_lock for RU %d slave %d (IC %d)\n",proc->ru->idx,slave_proc->ru->idx,slave_proc->instance_cnt_FH);
executables/lte-ru.c:        LOG_E( PHY, "ERROR pthread_cond_signal for RU %d, slave RU %d\n",proc->ru->idx,slave_proc->ru->idx);
executables/lte-ru.c:      LOG_W( PHY,"[RU] Frame %d, slave %d thread busy!! (cnt_FH %i)\n",slave_proc->frame_rx,slave_proc->ru->idx, cnt_slave);
executables/lte-ru.c:  RU_proc_t *proc = (RU_proc_t *)&ru->proc;
executables/lte-ru.c:  while (*ru->ru_mask>0 && ru->function!=eNodeB_3GPP) {
executables/lte-ru.c:    if (ru->eNB_list[0]) {
executables/lte-ru.c:        ru->eNB_list[0],0
executables/lte-ru.c:  RU_proc_t *proc = (RU_proc_t *)&ru->proc;
executables/lte-ru.c:  // lock the synch mutex and make sure the thread is readif (pthread_mutex_timedlock(&ru->proc.mutex_synch,&wait) != 0) {
executables/lte-ru.c:  AssertFatal((ret=pthread_mutex_timedlock(&ru->proc.mutex_synch,&wait)) == 0,"[RU] ERROR pthread_mutex_lock for RU synch thread (IC %d)\n", ru->proc.instance_cnt_synch );
executables/lte-ru.c:  ++ru->proc.instance_cnt_synch;
executables/lte-ru.c:  if (pthread_cond_signal(&ru->proc.cond_synch) != 0) {
executables/lte-ru.c:  AssertFatal((ret=pthread_mutex_unlock( &ru->proc.mutex_synch ))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp  = ru->frame_parms;
executables/lte-ru.c:  RU_proc_t *proc         = &ru->proc;
executables/lte-ru.c:  int32_t dummy_rx[ru->nb_rx][fp->samples_per_tti] __attribute__((aligned(32)));
executables/lte-ru.c:  for (int i=0; i<ru->nb_rx; i++)
executables/lte-ru.c:    rxp[i] = &ru->common.rxdata[i][0];
executables/lte-ru.c:  double temp_freq1 = ru->rfdevice.openair0_cfg->rx_freq[0];
executables/lte-ru.c:    ru->rfdevice.openair0_cfg->rx_freq[i] = ru->rfdevice.openair0_cfg->tx_freq[i];
executables/lte-ru.c:    ru->rfdevice.openair0_cfg->tx_freq[i] = temp_freq1;
executables/lte-ru.c:  ru->rfdevice.trx_set_freq_func(&ru->rfdevice,ru->rfdevice.openair0_cfg);
executables/lte-ru.c:  while ((ru->in_synch ==0)&&(!oai_exit)) {
executables/lte-ru.c:    rxs = ru->rfdevice.trx_read_func(&ru->rfdevice,
executables/lte-ru.c:                                     ru->nb_rx);
executables/lte-ru.c:      for (i=0; i<ru->nb_rx; i++)
executables/lte-ru.c:        rxs = ru->rfdevice.trx_read_func(&ru->rfdevice,
executables/lte-ru.c:                                         ru->nb_rx);
executables/lte-ru.c:      AssertFatal((ret=pthread_mutex_lock(&ru->proc.mutex_synch))==0,"mutex_lock returns %d\n",ret);
executables/lte-ru.c:      ic = ru->proc.instance_cnt_synch;
executables/lte-ru.c:      AssertFatal((ret=pthread_mutex_unlock(&ru->proc.mutex_synch))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:  LOG_I(PHY,"Resynchronizing by %d samples\n",ru->rx_offset);
executables/lte-ru.c:  rxs = ru->rfdevice.trx_read_func(&ru->rfdevice,
executables/lte-ru.c:                                   ru->rx_offset,
executables/lte-ru.c:                                   ru->nb_rx);
executables/lte-ru.c:  ru->state = RU_CHECK_SYNC;
executables/lte-ru.c:  if (labs(ru_master->proc.t[subframe].tv_nsec - ru->proc.t[subframe].tv_nsec) > 500000)
executables/lte-ru.c:  PHY_VARS_eNB **eNB_list = ru->eNB_list;
executables/lte-ru.c:  LOG_D(PHY, "wakeup_L1s (num %d) for RU %d (%d.%d) ru->eNB_top:%p\n", ru->num_eNB, ru->idx, ru->proc.frame_rx, ru->proc.tti_rx, ru->eNB_top);
executables/lte-ru.c:  sprintf(string, "Incoming RU %d", ru->idx);
executables/lte-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_WAKEUP_L1S_RU+ru->idx, ru->proc.frame_rx);
executables/lte-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_WAKEUP_L1S_RU+ru->idx, ru->proc.tti_rx);
executables/lte-ru.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_LOCK_MUTEX_RU+ru->idx, 1);
executables/lte-ru.c:  //          ru->proc.frame_rx,ru->proc.tti_rx,ru->idx,ru->wait_cnt,ru->proc.tti_rx,proc->RU_mask[ru->proc.tti_rx]);
executables/lte-ru.c:  //VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_WAKEUP_L1S_RU+ru->idx, ru->proc.frame_rx);
executables/lte-ru.c:  //VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_WAKEUP_L1S_RU+ru->idx, ru->proc.tti_rx);
executables/lte-ru.c:  clock_gettime(CLOCK_MONOTONIC, &ru->proc.t[ru->proc.tti_rx]);
executables/lte-ru.c:  if (proc->RU_mask[ru->proc.tti_rx] == 0) {
executables/lte-ru.c:    //clock_gettime(CLOCK_MONOTONIC,&proc->t[ru->proc.tti_rx]);
executables/lte-ru.c:    proc->t[ru->proc.tti_rx] = ru->proc.t[ru->proc.tti_rx];
executables/lte-ru.c:    LOG_D(PHY,"RU %d starting timer for frame %d subframe %d\n", ru->idx, ru->proc.frame_rx, ru->proc.tti_rx);
executables/lte-ru.c:    if (eNB->RU_list[i]->wait_cnt==1 && ru->proc.tti_rx!=9) eNB->RU_list[i]->wait_cnt=0;
executables/lte-ru.c:      //AssertFatal((proc->RU_mask&(1<<i)) == 0, "eNB %d frame %d, subframe %d : previous information from RU %d (num_RU %d,mask %x) has not been served yet!\n", eNB->Mod_id,ru->proc.frame_rx,ru->proc.tti_rx,ru->idx,eNB->num_RU,proc->RU_mask);
executables/lte-ru.c:      proc->RU_mask[ru->proc.tti_rx] |= (1<<i);
executables/lte-ru.c:    } else if (eNB->RU_list[i]->state == RU_SYNC ||(eNB->RU_list[i]->is_slave==1 && eNB->RU_list[i]->wait_cnt>0 && ru!=eNB->RU_list[i] /*&& ru->is_slave==0*/) ) {
executables/lte-ru.c:      proc->RU_mask[ru->proc.tti_rx] |= (1<<i);
executables/lte-ru.c:    //LOG_I(PHY,"RU %d, RU_mask[%d] %d, i %d, frame %d, slave %d, ru->cnt %d, i->cnt %d\n",ru->idx,ru->proc.tti_rx,proc->RU_mask[ru->proc.tti_rx],i,ru->proc.frame_rx,ru->is_slave,ru->wait_cnt,eNB->RU_list[i]->wait_cnt);
executables/lte-ru.c:    VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_MASK_RU, proc->RU_mask[ru->proc.tti_rx]);
executables/lte-ru.c:    if (ru->is_slave == 0 && ( (proc->RU_mask[ru->proc.tti_rx]&(1<<i)) == 1 ) && eNB->RU_list[i]->state == RU_RUN) { //This is master & the RRU has already been received
executables/lte-ru.c:      if (check_sync(eNB->RU_list[i],eNB->RU_list[0],ru->proc.tti_rx) == 0)
executables/lte-ru.c:              eNB->RU_list[i]->idx, ru->proc.tti_rx, labs(eNB->RU_list[i]->proc.t[ru->proc.tti_rx].tv_nsec - eNB->RU_list[0]->proc.t[ru->proc.tti_rx].tv_nsec));
executables/lte-ru.c:    } else if (ru->is_slave == 1 && ru->state == RU_RUN && ( (proc->RU_mask[ru->proc.tti_rx]&(1<<0)) == 1)) { // master already received. TODO: we assume that RU0 is master.
executables/lte-ru.c:      if (check_sync(ru,eNB->RU_list[0],ru->proc.tti_rx) == 0)
executables/lte-ru.c:              ru->idx, ru->proc.tti_rx, labs(ru->proc.t[ru->proc.tti_rx].tv_nsec - eNB->RU_list[0]->proc.t[ru->proc.tti_rx].tv_nsec));
executables/lte-ru.c:  //LOG_I(PHY,"RU mask is now %x, time is %lu\n",proc->RU_mask[ru->proc.tti_rx], t.tv_nsec - proc->t[ru->proc.tti_rx].tv_nsec);
executables/lte-ru.c:  if (proc->RU_mask[ru->proc.tti_rx] == (1<<eNB->num_RU)-1) { // all RUs have provided their information so continue on and wakeup eNB top
executables/lte-ru.c:    LOG_D(PHY,"ru_mask is %d \n ", proc->RU_mask[ru->proc.tti_rx]);
executables/lte-ru.c:    LOG_D(PHY,"the number of RU is %d, the current ru is RU %d \n ", (1<<eNB->num_RU)-1, ru->idx);
executables/lte-ru.c:    LOG_D(PHY,"ru->proc.tti_rx is %d \n", ru->proc.tti_rx);
executables/lte-ru.c:    LOG_D(PHY,"Resetting mask frame %d, subframe %d, this is RU %d\n", ru->proc.frame_rx, ru->proc.tti_rx, ru->idx);
executables/lte-ru.c:    proc->RU_mask[ru->proc.tti_rx] = 0;
executables/lte-ru.c:    VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_MASK_RU, proc->RU_mask[ru->proc.tti_rx]);
executables/lte-ru.c:    /*AssertFatal(t.tv_nsec < proc->t[ru->proc.tti_rx].tv_nsec+5000000, "Time difference for subframe %d (Frame %d) => %lu > 5ms, this is RU %d\n",
executables/lte-ru.c:                  ru->proc.tti_rx, ru->proc.frame_rx, t.tv_nsec - proc->t[ru->proc.tti_rx].tv_nsec, ru->idx);*/
executables/lte-ru.c:    //VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_WAKEUP_L1S_RU+ru->idx, ru->proc.frame_rx);
executables/lte-ru.c:    //VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_WAKEUP_L1S_RU+ru->idx, ru->proc.tti_rx);
executables/lte-ru.c:    VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_LOCK_MUTEX_RU+ru->idx, 0 );
executables/lte-ru.c:    LOG_D(PHY,"RU %d wakeup eNB top for subframe %d\n", ru->idx, ru->proc.tti_rx);
executables/lte-ru.c:    if (ru->wait_cnt == 0) {
executables/lte-ru.c:      if (ru->num_eNB==1 && ru->eNB_top!=0 && get_thread_parallel_conf() == PARALLEL_SINGLE_THREAD) {
executables/lte-ru.c:        LOG_D(PHY,"RU %d Call eNB_top\n", ru->idx);
executables/lte-ru.c:        ru->eNB_top(eNB_list[0], proc->frame_rx, proc->subframe_rx, string, ru);
executables/lte-ru.c:        for (int i=0; i<ru->num_eNB; i++) {
executables/lte-ru.c:          LOG_D(PHY,"ru->wakeup_rxtx:%p\n", ru->wakeup_rxtx);
executables/lte-ru.c:          eNB_list[i]->proc.ru_proc = &ru->proc;
executables/lte-ru.c:          if (ru->wakeup_rxtx!=0 && ru->wakeup_rxtx(eNB_list[i],ru) < 0) LOG_E(PHY,"could not wakeup eNB rxtx process for subframe %d\n", ru->proc.tti_rx);
executables/lte-ru.c:      LOG_D(PHY,"RU %d sending signal to unlock waiting ru_threads\n", ru->idx);
executables/lte-ru.c:    VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_LOCK_MUTEX_RU+ru->idx, 0 );
executables/lte-ru.c:  //      LOG_D(PHY,"wakeup eNB top for for subframe %d\n", ru->proc.tti_rx);
executables/lte-ru.c:  //      ru->eNB_top(eNB_list[0],ru->proc.frame_rx,ru->proc.tti_rx,string);
executables/lte-ru.c:  ru->proc.emulate_rf_busy = 0;
executables/lte-ru.c:  AssertFatal((ret=pthread_mutex_timedlock(&ru->proc.mutex_prach,&wait)) == 0,"[RU] ERROR pthread_mutex_lock for RU prach thread (IC %d)\n", ru->proc.instance_cnt_prach);
executables/lte-ru.c:  if (ru->proc.instance_cnt_prach==-1) {
executables/lte-ru.c:    ++ru->proc.instance_cnt_prach;
executables/lte-ru.c:    ru->proc.frame_prach    = ru->proc.frame_rx;
executables/lte-ru.c:    ru->proc.subframe_prach = ru->proc.tti_rx;
executables/lte-ru.c:    if (ru->eNB_list[0]) {
executables/lte-ru.c:      ru->eNB_list[0]->proc.frame_prach = ru->proc.frame_rx;
executables/lte-ru.c:      ru->eNB_list[0]->proc.subframe_prach = ru->proc.tti_rx;
executables/lte-ru.c:    LOG_D(PHY,"RU %d: waking up PRACH thread\n",ru->idx);
executables/lte-ru.c:    AssertFatal(pthread_cond_signal(&ru->proc.cond_prach) == 0, "ERROR pthread_cond_signal for RU prach thread\n");
executables/lte-ru.c:  AssertFatal((ret=pthread_mutex_unlock( &ru->proc.mutex_prach ))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:  AssertFatal((ret=pthread_mutex_timedlock(&ru->proc.mutex_prach_br,&wait))==0,"[RU] ERROR pthread_mutex_lock for RU prach thread BR (IC %d)\n", ru->proc.instance_cnt_prach_br);
executables/lte-ru.c:  if (ru->proc.instance_cnt_prach_br==-1) {
executables/lte-ru.c:    ++ru->proc.instance_cnt_prach_br;
executables/lte-ru.c:    ru->proc.frame_prach_br    = ru->proc.frame_rx;
executables/lte-ru.c:    ru->proc.subframe_prach_br = ru->proc.tti_rx;
executables/lte-ru.c:    LOG_D(PHY,"RU %d: waking up PRACH thread\n",ru->idx);
executables/lte-ru.c:    AssertFatal(pthread_cond_signal(&ru->proc.cond_prach_br) == 0, "ERROR pthread_cond_signal for RU prach thread BR\n");
executables/lte-ru.c:  AssertFatal((ret=pthread_mutex_unlock( &ru->proc.mutex_prach_br ))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp   = ru->frame_parms;
executables/lte-ru.c:  openair0_config_t *cfg   = &ru->openair0_cfg;
executables/lte-ru.c:    if(ru->numerology == 0) {
executables/lte-ru.c:    } else if(ru->numerology == 1) {
executables/lte-ru.c:    } else if(ru->numerology == 2) {
executables/lte-ru.c:  cfg->tx_num_channels=ru->nb_tx;
executables/lte-ru.c:  cfg->rx_num_channels=ru->nb_rx;
executables/lte-ru.c:  for (int i=0; i<ru->nb_tx; i++) {
executables/lte-ru.c:    cfg->tx_gain[i] = (double)ru->att_tx;
executables/lte-ru.c:    cfg->rx_gain[i] = ru->max_rxgain-(double)ru->att_rx;
executables/lte-ru.c:    frame_parms = ru->frame_parms;
executables/lte-ru.c:    if      (frame_parms->N_RB_DL == 100) ru->N_TA_offset = 624;
executables/lte-ru.c:    else if (frame_parms->N_RB_DL == 50)  ru->N_TA_offset = 624/2;
executables/lte-ru.c:    else if (frame_parms->N_RB_DL == 25)  ru->N_TA_offset = 624/4;
executables/lte-ru.c:      ru->sf_extension       /= 2;
executables/lte-ru.c:      ru->end_of_burst_delay /= 2;
executables/lte-ru.c:      ru->sf_extension       /= 4;
executables/lte-ru.c:      ru->end_of_burst_delay /= 4;
executables/lte-ru.c:    ru->N_TA_offset = 0;
executables/lte-ru.c:    ru->sf_extension = 0;
executables/lte-ru.c:    ru->end_of_burst_delay = 0;
executables/lte-ru.c:  if (ru->openair0_cfg.mmapped_dma == 1) {
executables/lte-ru.c:    for (i=0; i<ru->nb_rx; i++) {
executables/lte-ru.c:      LOG_I(PHY,"Mapping RU id %d, rx_ant %d, on card %d, chain %d\n",ru->idx,i,ru->rf_map.card+card, ru->rf_map.chain+ant);
executables/lte-ru.c:      free(ru->common.rxdata[i]);
executables/lte-ru.c:      ru->common.rxdata[i] = ru->openair0_cfg.rxbase[ru->rf_map.chain+ant];
executables/lte-ru.c:      LOG_I(PHY,"rxdata[%d] @ %p\n",i,ru->common.rxdata[i]);
executables/lte-ru.c:        LOG_I(PHY,"rxbuffer %d: %x\n",j,ru->common.rxdata[i][j]);
executables/lte-ru.c:        ru->common.rxdata[i][j] = 16-j;
executables/lte-ru.c:    for (i=0; i<ru->nb_tx; i++) {
executables/lte-ru.c:      LOG_I(PHY,"Mapping RU id %d, tx_ant %d, on card %d, chain %d\n",ru->idx,i,ru->rf_map.card+card, ru->rf_map.chain+ant);
executables/lte-ru.c:      free(ru->common.txdata[i]);
executables/lte-ru.c:      ru->common.txdata[i] = ru->openair0_cfg.txbase[ru->rf_map.chain+ant];
executables/lte-ru.c:      LOG_I(PHY,"txdata[%d] @ %p\n",i,ru->common.txdata[i]);
executables/lte-ru.c:        LOG_I(PHY,"txbuffer %d: %x\n",j,ru->common.txdata[i][j]);
executables/lte-ru.c:        ru->common.txdata[i][j] = 16-j;
executables/lte-ru.c:      if (ru->feprx) print_meas(&ru->ofdm_demod_stats,"feprx_ru",NULL,NULL);
executables/lte-ru.c:      if (ru->feptx_ofdm) print_meas(&ru->ofdm_mod_stats,"feptx_ofdm_ru",NULL,NULL);
executables/lte-ru.c:      if (ru->fh_north_asynch_in) print_meas(&ru->rx_fhaul,"rx_fhaul_ru",NULL,NULL);
executables/lte-ru.c:      if (ru->fh_north_out) {
executables/lte-ru.c:        print_meas(&ru->tx_fhaul,"tx_fhaul",NULL,NULL);
executables/lte-ru.c:        print_meas(&ru->compression,"compression",NULL,NULL);
executables/lte-ru.c:        print_meas(&ru->transport,"transport",NULL,NULL);
executables/lte-ru.c:        LOG_I(PHY,"ru->north_out_cnt = %d\n",ru->north_out_cnt);
executables/lte-ru.c:      if (ru->fh_south_out) LOG_I(PHY,"ru->south_out_cnt = %d\n",ru->south_out_cnt);
executables/lte-ru.c:      if (ru->fh_north_asynch_in) LOG_I(PHY,"ru->north_in_cnt = %d\n",ru->north_in_cnt);
executables/lte-ru.c:  RU_proc_t *proc  = &ru->proc;
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:    LOG_D(PHY,"ru_thread_tx (ru %d): Waiting for TX processing\n",ru->idx);
executables/lte-ru.c:    if (ru->feptx_prec) ru->feptx_prec(ru,frame_tx,tti_tx);
executables/lte-ru.c:    if ((ru->fh_north_asynch_in == NULL) && (ru->feptx_ofdm)) ru->feptx_ofdm(ru,frame_tx,tti_tx);
executables/lte-ru.c:    if(!(ru->emulate_rf)) { //if(!emulate_rf){
executables/lte-ru.c:      if ((ru->fh_north_asynch_in == NULL) && (ru->fh_south_out)) ru->fh_south_out(ru,frame_tx,tti_tx,timestamp_tx);
executables/lte-ru.c:      if (ru->fh_north_out) ru->fh_north_out(ru);
executables/lte-ru.c:      for (int i=0; i<ru->nb_tx; i++) {
executables/lte-ru.c:          LOG_M(filename,"txdataF_frame",ru->common.txdataF_BF[i],fp->symbols_per_tti*fp->ofdm_symbol_size, 1, 1);
executables/lte-ru.c:          LOG_M(filename,"txdata_frame",ru->common.txdata[i],fp->samples_per_tti*10, 1, 1);
executables/lte-ru.c:    for(int i = 0; i<ru->num_eNB; i++) {
executables/lte-ru.c:      eNB       = ru->eNB_list[i];
executables/lte-ru.c:                  eNB->Mod_id,eNB_proc->frame_rx,eNB_proc->subframe_rx,ru->idx,eNB->num_RU,eNB_proc->RU_mask_tx);
executables/lte-ru.c:        //LOG_I(PHY,"Not all RUs have provided their info (mask = %d), RU %d, num_RUs %d\n", eNB_proc->RU_mask_tx,ru->idx,eNB->num_RU);
executables/lte-ru.c:    //eNB_proc->frame_rx,eNB_proc->subframe_rx,ru->idx,ru->wait_cnt,eNB_proc->RU_mask_tx);
executables/lte-ru.c:  RU_proc_t *proc  = &ru->proc;
executables/lte-ru.c:  LOG_I(PHY,"Starting RU %d (%s,%s),\n", ru->idx, NB_functions[ru->function], NB_timing[ru->if_timing]);
executables/lte-ru.c:    LOG_I(PHY, "Signaling main thread that RU %d is ready\n",ru->idx);
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_lock(ru->ru_mutex))==0,"mutex_lock returns %d\n",ret);
executables/lte-ru.c:    *ru->ru_mask &= ~(1<<ru->idx);
executables/lte-ru.c:    pthread_cond_signal(ru->ru_cond);
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_unlock(ru->ru_mutex))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:    ru->state = RU_RUN;
executables/lte-ru.c:  } else if (ru->has_ctrl_prt == 0) {
executables/lte-ru.c:    LOG_I(PHY, "RU %d has no OAI ctrl port\n",ru->idx);
executables/lte-ru.c:    fill_rf_config(ru,ru->rf_config_file);
executables/lte-ru.c:    init_frame_parms(ru->frame_parms,1);
executables/lte-ru.c:    ru->frame_parms->nb_antennas_rx = ru->nb_rx;
executables/lte-ru.c:    if (ru->if_south == LOCAL_RF)       openair0_device_load(&ru->rfdevice,&ru->openair0_cfg);
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_lock(ru->ru_mutex))==0,"mutex_lock returns %d\n",ret);
executables/lte-ru.c:    *ru->ru_mask &= ~(1<<ru->idx);
executables/lte-ru.c:    pthread_cond_signal(ru->ru_cond);
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_unlock(ru->ru_mutex))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:    ru->state = RU_RUN;
executables/lte-ru.c:     if (ru->start_write_thread){
executables/lte-ru.c:        if(ru->start_write_thread(ru) != 0){
executables/lte-ru.c:    if (ru->if_south != LOCAL_RF && ru->is_slave==1) {
executables/lte-ru.c:      ru->wait_cnt = 100;
executables/lte-ru.c:      ru->wait_cnt = 0;
executables/lte-ru.c:      ru->wait_check = 0;
executables/lte-ru.c:    if (ru->function!=eNodeB_3GPP && ru->has_ctrl_prt == 1) {
executables/lte-ru.c:      LOG_D(PHY,"RU %d: Waiting for control thread to say go\n",ru->idx);
executables/lte-ru.c:      if (wait_on_condition(&ru->proc.mutex_ru,&ru->proc.cond_ru_thread,&ru->proc.instance_cnt_ru,"ru_thread")<0) break;
executables/lte-ru.c:    LOG_D(PHY,"RU %d: Got start from control thread\n",ru->idx);
executables/lte-ru.c:    if(!(ru->emulate_rf)) {
executables/lte-ru.c:      if (ru->is_slave == 0) AssertFatal(ru->state == RU_RUN,"ru-%d state = %s != RU_RUN\n",ru->idx,ru_states[ru->state]);
executables/lte-ru.c:      else if (ru->is_slave == 1) AssertFatal(ru->state == RU_SYNC || ru->state == RU_RUN ||
executables/lte-ru.c:                                                ru->state == RU_CHECK_SYNC,"ru %d state = %s != RU_SYNC or RU_RUN or RU_CHECK_SYNC\n",ru->idx,ru_states[ru->state]);
executables/lte-ru.c:      if (ru->start_rf) {
executables/lte-ru.c:	if (ru->start_rf(ru) != 0)
executables/lte-ru.c:	else LOG_I(PHY,"RU %d rf device ready\n",ru->idx);
executables/lte-ru.c:      } else LOG_D(PHY,"RU %d no rf device\n",ru->idx);
executables/lte-ru.c:    if ((ru->fh_south_asynch_in)||(ru->fh_north_asynch_in)) {
executables/lte-ru.c:    } else LOG_D(PHY,"RU %d no asynch_south interface\n",ru->idx);
executables/lte-ru.c:    if ((ru->is_slave == 1) && (ru->if_south == LOCAL_RF)) do_ru_synch(ru);
executables/lte-ru.c:    if (ru->state == RU_RUN || ru->state == RU_CHECK_SYNC) LOG_I(PHY,"RU %d Starting steady-state operation\n",ru->idx);
executables/lte-ru.c:    while (ru->state == RU_RUN || ru->state == RU_CHECK_SYNC) {
executables/lte-ru.c:      if (ru->fh_south_in) ru->fh_south_in(ru,&frame,&subframe);
executables/lte-ru.c:        AssertFatal((ret=pthread_mutex_lock(&ru->proc.mutex_phy_tx))==0,"[RU] ERROR pthread_mutex_lock for phy tx thread (IC %d)\n", ru->proc.instance_cnt_phy_tx);
executables/lte-ru.c:        if (ru->proc.instance_cnt_phy_tx==-1) {
executables/lte-ru.c:          ++ru->proc.instance_cnt_phy_tx;
executables/lte-ru.c:          AssertFatal(pthread_cond_signal(&ru->proc.cond_phy_tx) == 0, "ERROR pthread_cond_signal for phy_tx thread\n");
executables/lte-ru.c:          ++ru->proc.instance_cnt_phy_tx;
executables/lte-ru.c:        AssertFatal((ret=pthread_mutex_unlock( &ru->proc.mutex_phy_tx ))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:      if (ru->stop_rf && ru->cmd == STOP_RU) {
executables/lte-ru.c:        ru->stop_rf(ru);
executables/lte-ru.c:        ru->state = RU_IDLE;
executables/lte-ru.c:        ru->cmd   = EMPTY;
executables/lte-ru.c:        LOG_I(PHY,"RU %d rf device stopped\n",ru->idx);
executables/lte-ru.c:      } else if (ru->cmd == STOP_RU) {
executables/lte-ru.c:        ru->state = RU_IDLE;
executables/lte-ru.c:        ru->cmd   = EMPTY;
executables/lte-ru.c:        LOG_I(PHY,"RU %d stopped\n",ru->idx);
executables/lte-ru.c:      if (ru->wait_cnt > 0) {
executables/lte-ru.c:        ru->wait_cnt--;
executables/lte-ru.c:        LOG_D(PHY,"RU thread %d, frame %d, subframe %d, wait_cnt %d \n",ru->idx, frame, subframe, ru->wait_cnt);
executables/lte-ru.c:        if (ru->if_south!=LOCAL_RF && ru->wait_cnt <=20 && subframe == 5 && frame != ru->ru0->proc.frame_rx && resynch_done == 0) {
executables/lte-ru.c:          ((uint16_t *)&rru_config_msg.msg[0])[0] = ru->ru0->proc.frame_rx;
executables/lte-ru.c:          ru->cmd=WAIT_RESYNCH;
executables/lte-ru.c:          LOG_I(PHY,"Sending Frame Resynch %d to RRU %d\n", ru->ru0->proc.frame_rx,ru->idx);
executables/lte-ru.c:          AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),"Failed to send msg to RAU\n");
executables/lte-ru.c:              ru->idx, frame, subframe, ru->do_prach, is_prach_subframe(ru->frame_parms, proc->frame_rx, proc->tti_rx));
executables/lte-ru.c:        if ((ru->do_prach>0) && (is_prach_subframe(ru->frame_parms, proc->frame_rx, proc->tti_rx)==1)) {
executables/lte-ru.c:        } else if ((ru->do_prach>0) && (is_prach_subframe(ru->frame_parms, proc->frame_rx, proc->tti_rx)>1)) {
executables/lte-ru.c:        if (ru->idx!=0) proc->frame_tx = (proc->frame_tx+proc->frame_offset)&1023;
executables/lte-ru.c:        if (ru->feprx) ru->feprx(ru, proc->tti_rx);
executables/lte-ru.c:        memcpy(&pre_scd_eNB_UE_stats,&RC.mac[ru->eNB_list[0]->Mod_id]->UE_info.eNB_UE_stats, sizeof(eNB_UE_STATS)*MAX_NUM_CCs*NUMBER_OF_UE_MAX);
executables/lte-ru.c:        memcpy(&pre_scd_activeUE, &RC.mac[ru->eNB_list[0]->Mod_id]->UE_info.active, sizeof(bool)*NUMBER_OF_UE_MAX);
executables/lte-ru.c:        AssertFatal((ret=pthread_mutex_lock(&ru->proc.mutex_pre_scd))==0,"[eNB] error locking proc mutex for eNB pre scd\n");
executables/lte-ru.c:        ru->proc.instance_pre_scd++;
executables/lte-ru.c:        if (ru->proc.instance_pre_scd == 0) {
executables/lte-ru.c:          if (pthread_cond_signal(&ru->proc.cond_pre_scd) != 0) {
executables/lte-ru.c:                 frame,subframe,ru->proc.instance_pre_scd );
executables/lte-ru.c:        AssertFatal((ret=pthread_mutex_unlock(&ru->proc.mutex_pre_scd))==0,"[eNB] error unlocking mutex_pre_scd mutex for eNB pre scd\n");
executables/lte-ru.c:	if (ru->num_eNB>0) wakeup_L1s(ru);
executables/lte-ru.c:	if(ru->if_south==LOCAL_RF && ru->function==eNodeB_3GPP && ru->eNB_list[0]!=NULL){
executables/lte-ru.c:		if(ru->frame_parms->num_MBSFN_config!=ru->eNB_list[0]->frame_parms.num_MBSFN_config){
executables/lte-ru.c:			ru->frame_parms = &ru->eNB_list[0]->frame_parms;//->frame_parms;
executables/lte-ru.c:        if(get_thread_parallel_conf() == PARALLEL_SINGLE_THREAD || ru->num_eNB==0) {
executables/lte-ru.c:          if (ru->feptx_prec) ru->feptx_prec(ru, proc->frame_tx, proc->tti_tx);
executables/lte-ru.c:          if ((ru->fh_north_asynch_in == NULL) && (ru->feptx_ofdm)) ru->feptx_ofdm(ru, proc->frame_tx, proc->tti_tx);
executables/lte-ru.c:          if(!(ru->emulate_rf)) { //if(!emulate_rf){
executables/lte-ru.c:            if ((ru->fh_north_asynch_in == NULL) && (ru->fh_south_out)) ru->fh_south_out(ru, proc->frame_tx, proc->tti_tx, proc->timestamp_tx);
executables/lte-ru.c:            if ((ru->fh_north_out) && (ru->state!=RU_CHECK_SYNC)) ru->fh_north_out(ru);
executables/lte-ru.c:            for (int i=0; i<ru->nb_tx; i++) {
executables/lte-ru.c:                LOG_M(filename,"txdataF_frame",ru->common.txdataF_BF[i],ru->frame_parms->symbols_per_tti*ru->frame_parms->ofdm_symbol_size, 1, 1);
executables/lte-ru.c:                LOG_M(filename,"txdata_frame",ru->common.txdata[i],ru->frame_parms->samples_per_tti*10, 1, 1);
executables/lte-ru.c:    } // ru->state = RU_RUN || RU_CHECK_SYNC
executables/lte-ru.c:  if (!(ru->emulate_rf)) {
executables/lte-ru.c:    if (ru->stop_rf != NULL) {
executables/lte-ru.c:      if (ru->stop_rf(ru) != 0)
executables/lte-ru.c:      else LOG_I(PHY,"RU %d rf device stopped\n",ru->idx);
executables/lte-ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
executables/lte-ru.c:  ru_sync_time_init(ru); //lte_sync_time_init(ru->frame_parms);
executables/lte-ru.c:  fp = ru->frame_parms;
executables/lte-ru.c:    if (wait_on_condition(&ru->proc.mutex_synch,&ru->proc.cond_synch,&ru->proc.instance_cnt_synch,"ru_thread_synch")<0) break;
executables/lte-ru.c:    if (ru->in_synch == 0) {
executables/lte-ru.c:      ru->rx_offset = ru_sync_time(ru,
executables/lte-ru.c:      LOG_I(PHY,"RU synch cnt %d: %d, val %llu (%d dB,%d dB)\n",cnt,ru->rx_offset,(unsigned long long)peak_val,dB_fixed64(peak_val),dB_fixed64(avg));
executables/lte-ru.c:      int abs_diff= ru->rx_offset - last_rxoff;
executables/lte-ru.c:      if (ru->rx_offset >= 0 && abs_diff<6 && avg>0 && dB_fixed(peak_val/avg)>=15 && cnt>10) {
executables/lte-ru.c:        LOG_I(PHY,"Estimated peak_val %d dB, avg %d => timing offset %llu\n",dB_fixed(peak_val),dB_fixed(avg),(unsigned long long int)ru->rx_offset);
executables/lte-ru.c:        ru->in_synch = 1;
executables/lte-ru.c:                LOG_M("ru_sync_rx.m","rurx",&ru->common.rxdata[0][0],LTE_NUMBER_OF_SUBFRAMES_PER_FRAME*fp->samples_per_tti,1,1);
executables/lte-ru.c:                LOG_M("ru_sync_corr.m","sync_corr",ru->dmrs_corr,LTE_NUMBER_OF_SUBFRAMES_PER_FRAME*fp->samples_per_tti,1,6);
executables/lte-ru.c:                LOG_M("ru_dmrs.m","rudmrs",&ru->dmrssync[0],fp->ofdm_symbol_size,1,1);
executables/lte-ru.c:          LOG_M("ru_sync_rx.m","rurx",&ru->common.rxdata[0][0],LTE_NUMBER_OF_SUBFRAMES_PER_FRAME*fp->samples_per_tti,1,1);
executables/lte-ru.c:          LOG_M("ru_sync_corr.m","sync_corr",ru->dmrs_corr,LTE_NUMBER_OF_SUBFRAMES_PER_FRAME*fp->samples_per_tti,1,6);
executables/lte-ru.c:          LOG_M("ru_dmrs.m","rudmrs",&ru->dmrssync[0],fp->ofdm_symbol_size,1,1);
executables/lte-ru.c:      last_rxoff=ru->rx_offset;
executables/lte-ru.c:    } // ru->in_synch==0
executables/lte-ru.c:    if (release_thread(&ru->proc.mutex_synch,&ru->proc.instance_cnt_synch,"ru_synch_thread") < 0) break;
executables/lte-ru.c:    Mod_id = ru->eNB_list[0]->Mod_id;
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_lock(&ru->proc.mutex_pre_scd ))==0,"mutex_lock returns %d\n",ret);
executables/lte-ru.c:    if (ru->proc.instance_pre_scd < 0) {
executables/lte-ru.c:      pthread_cond_wait(&ru->proc.cond_pre_scd, &ru->proc.mutex_pre_scd);
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_unlock(&ru->proc.mutex_pre_scd))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_lock(&ru->proc.mutex_pre_scd ))==0,"mutex_lock returns %d\n",ret);
executables/lte-ru.c:    ru->proc.instance_pre_scd--;
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_unlock(&ru->proc.mutex_pre_scd))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:  RU_proc_t *proc = &ru->proc;
executables/lte-ru.c:  PHY_VARS_eNB **eNB_list = ru->eNB_list;
executables/lte-ru.c:    AssertFatal(ru->num_eNB == 1, "Handle multiple L1 case\n");
executables/lte-ru.c:    if(ru->num_eNB == 1) {
executables/lte-ru.c:      if(pthread_mutex_lock(&ru->proc.mutex_rf_tx) != 0) {
executables/lte-ru.c:        LOG_E(PHY, "[RU] ERROR pthread_mutex_lock for rf tx thread (IC %d)\n", ru->proc.instance_cnt_rf_tx);
executables/lte-ru.c:      if (ru->proc.instance_cnt_rf_tx==-1) {
executables/lte-ru.c:        ++ru->proc.instance_cnt_rf_tx;
executables/lte-ru.c:        ru->proc.frame_tx     = proc->frame_phy_tx;
executables/lte-ru.c:        ru->proc.tti_tx       = proc->subframe_phy_tx;
executables/lte-ru.c:        ru->proc.timestamp_tx = proc->timestamp_phy_tx;
executables/lte-ru.c:        AssertFatal(pthread_cond_signal(&ru->proc.cond_rf_tx) == 0, "ERROR pthread_cond_signal for rf_tx thread\n");
executables/lte-ru.c:      pthread_mutex_unlock( &ru->proc.mutex_rf_tx );
executables/lte-ru.c:    AssertFatal((ret=pthread_mutex_unlock( &ru->proc.mutex_rf_tx ))==0,"mutex_unlock returns %d\n",ret);
executables/lte-ru.c:  RU_proc_t *proc = &ru->proc;
executables/lte-ru.c:    if(ru->num_eNB == 1) {
executables/lte-ru.c:      if (ru->feptx_prec) ru->feptx_prec(ru);
executables/lte-ru.c:      if ((ru->fh_north_asynch_in == NULL) && (ru->feptx_ofdm)) ru->feptx_ofdm(ru,proc->frame_tx,proc->tti_tx);
executables/lte-ru.c:      if(!ru->emulate_rf) {
executables/lte-ru.c:        if ((ru->fh_north_asynch_in == NULL) && (ru->fh_south_out)) ru->fh_south_out(ru,proc->frame_tx,proc->tti_tx,proc->timestamp_tx);
executables/lte-ru.c:        if (ru->fh_north_out) ru->fh_north_out(ru);
executables/lte-ru.c:  return(ru->ifdevice.thirdparty_startstreaming(&ru->ifdevice));
executables/lte-ru.c:  return(ru->ifdevice.trx_start_func(&ru->ifdevice));
executables/lte-ru.c:  return(ru->rfdevice.trx_start_func(&ru->rfdevice));
executables/lte-ru.c:    if(ru->rfdevice.trx_end_func != NULL) {
executables/lte-ru.c:      ru->rfdevice.trx_end_func(&ru->rfdevice);
executables/lte-ru.c:  proc = &ru->proc;
executables/lte-ru.c:    return(ru->rfdevice.trx_write_init(&ru->rfdevice));
executables/lte-ru.c:  LOG_I(PHY,"Initializing RU proc %d (%s,%s),\n",ru->idx,NB_functions[ru->function],NB_timing[ru->if_timing]);
executables/lte-ru.c:  proc = &ru->proc;
executables/lte-ru.c:  if (ru->has_ctrl_prt == 1) pthread_create( &proc->pthread_ctrl, attr_ctrl, ru_thread_control, (void*)ru );
executables/lte-ru.c:    if (ru->start_if) {
executables/lte-ru.c:      LOG_I(PHY,"Starting IF interface for RU %d\n",ru->idx);
executables/lte-ru.c:                  ru->start_if(ru,NULL)   == 0, "Could not start the IF device\n");
executables/lte-ru.c:      if (ru->if_south != LOCAL_RF) wait_eNBs();
executables/lte-ru.c:  if (ru->emulate_rf)
executables/lte-ru.c:  if (ru->function == NGFI_RRU_IF4p5) {
executables/lte-ru.c:    if (ru->is_slave == 1) pthread_create( &proc->pthread_synch, attr_synch, ru_thread_synch, (void *)ru);
executables/lte-ru.c:    if ((ru->if_timing == synch_to_other) || (ru->function == NGFI_RRU_IF5) || (ru->function == NGFI_RRU_IF4p5)) {
executables/lte-ru.c:      LOG_I(PHY,"Starting ru_thread_asynch_rxtx, ru->is_slave %d, ru->generate_dmrs_sync %d\n",
executables/lte-ru.c:            ru->is_slave,ru->generate_dmrs_sync);
executables/lte-ru.c:      //ru->dmrssync = (int16_t*)malloc16_clear(ru->frame_parms.ofdm_symbol_size*2*sizeof(int16_t));
executables/lte-ru.c:  } else if (ru->function == eNodeB_3GPP && ru->if_south == LOCAL_RF) { // DJP - need something else to distinguish between monolithic and PNF
executables/lte-ru.c:    ru->state=RU_RUN;
executables/lte-ru.c:    pthread_create(&ru->ru_stats_thread, NULL, ru_stats_thread, (void *)ru);
executables/lte-ru.c:  RU_proc_t *proc = &ru->proc;
executables/lte-ru.c:  ru->proc.instance_pre_scd = 0;
executables/lte-ru.c:  pthread_join(ru->proc.pthread_phy_tx, NULL);
executables/lte-ru.c:  if (ru->function == NGFI_RRU_IF4p5) {
executables/lte-ru.c:    if (ru->is_slave) {
executables/lte-ru.c:    if ((ru->if_timing == synch_to_other) ||
executables/lte-ru.c:        (ru->function == NGFI_RRU_IF5) ||
executables/lte-ru.c:        (ru->function == NGFI_RRU_IF4p5)) {
executables/lte-ru.c:    pthread_join(ru->ru_stats_thread, NULL);
executables/lte-ru.c:          nb_tx+=ru->nb_tx;
executables/lte-ru.c:  switch (ru->if_south) {
executables/lte-ru.c:      if (ru->function ==  NGFI_RRU_IF5) {                 // IF5 RRU
executables/lte-ru.c:        ru->do_prach              = 0;                      // no prach processing in RU
executables/lte-ru.c:        ru->fh_north_in           = NULL;                   // no shynchronous incoming fronthaul from north
executables/lte-ru.c:        ru->fh_north_out          = fh_if5_north_out;       // need only to do send_IF5  reception
executables/lte-ru.c:        ru->fh_south_out          = tx_rf;                  // send output to RF
executables/lte-ru.c:        ru->fh_north_asynch_in    = fh_if5_north_asynch_in; // TX packets come asynchronously
executables/lte-ru.c:        ru->feprx                 = NULL;                   // nothing (this is a time-domain signal)
executables/lte-ru.c:        ru->feptx_ofdm            = NULL;                   // nothing (this is a time-domain signal)
executables/lte-ru.c:        ru->feptx_prec            = NULL;                   // nothing (this is a time-domain signal)
executables/lte-ru.c:        ru->start_if              = start_if;               // need to start the if interface for if5
executables/lte-ru.c:        ru->ifdevice.host_type    = RRU_HOST;
executables/lte-ru.c:        ru->rfdevice.host_type    = RRU_HOST;
executables/lte-ru.c:        ru->ifdevice.eth_params   = &ru->eth_params;
executables/lte-ru.c:        reset_meas(&ru->rx_fhaul);
executables/lte-ru.c:        reset_meas(&ru->tx_fhaul);
executables/lte-ru.c:        reset_meas(&ru->compression);
executables/lte-ru.c:        reset_meas(&ru->transport);
executables/lte-ru.c:        ret = openair0_transport_load(&ru->ifdevice,&ru->openair0_cfg,&ru->eth_params);
executables/lte-ru.c:        LOG_I(PHY,"NGFI_RRU_IF5: openair0_transport_init returns %d for ru_id %d\n", ret, ru->idx);
executables/lte-ru.c:      } else if (ru->function == NGFI_RRU_IF4p5) {
executables/lte-ru.c:        ru->do_prach              = 1;                        // do part of prach processing in RU
executables/lte-ru.c:        ru->fh_north_in           = NULL;                     // no synchronous incoming fronthaul from north
executables/lte-ru.c:        ru->fh_north_out          = fh_if4p5_north_out;       // send_IF4p5 on reception
executables/lte-ru.c:        ru->fh_south_out          = tx_rf;                    // send output to RF
executables/lte-ru.c:        ru->fh_north_asynch_in    = fh_if4p5_north_asynch_in; // TX packets come asynchronously
executables/lte-ru.c:        ru->feprx                 = (get_thread_worker_conf() == WORKER_DISABLE) ? fep_full :ru_fep_full_2thread;                 // RX DFTs
executables/lte-ru.c:        ru->feptx_ofdm            = (get_thread_worker_conf() == WORKER_DISABLE) ? feptx_ofdm : feptx_ofdm_2thread;               // this is fep with idft only (no precoding in RRU)
executables/lte-ru.c:        ru->feptx_prec            = NULL;
executables/lte-ru.c:        ru->start_if              = start_if;                 // need to start the if interface for if4p5
executables/lte-ru.c:        ru->ifdevice.host_type    = RRU_HOST;
executables/lte-ru.c:        ru->rfdevice.host_type    = RRU_HOST;
executables/lte-ru.c:        ru->ifdevice.eth_params   = &ru->eth_params;
executables/lte-ru.c:        reset_meas(&ru->rx_fhaul);
executables/lte-ru.c:        reset_meas(&ru->tx_fhaul);
executables/lte-ru.c:        reset_meas(&ru->compression);
executables/lte-ru.c:        reset_meas(&ru->transport);
executables/lte-ru.c:        ret = openair0_transport_load(&ru->ifdevice,&ru->openair0_cfg,&ru->eth_params);
executables/lte-ru.c:        LOG_I(PHY,"NGFI_RRU_if4p5 : openair0_transport_init returns %d for ru_id %d\n", ret, ru->idx);
executables/lte-ru.c:      } else if (ru->function == eNodeB_3GPP) {
executables/lte-ru.c:        ru->do_prach             = 0;                       // no prach processing in RU
executables/lte-ru.c:        ru->feprx                = (get_thread_worker_conf() == WORKER_DISABLE) ? fep_full : ru_fep_full_2thread;                // RX DFTs
executables/lte-ru.c:        ru->feptx_ofdm           = (get_thread_worker_conf() == WORKER_DISABLE) ? feptx_ofdm : feptx_ofdm_2thread;              // this is fep with idft and precoding
executables/lte-ru.c:        ru->feptx_prec           = feptx_prec;              // this is fep with idft and precoding
executables/lte-ru.c:        ru->fh_north_in          = NULL;                    // no incoming fronthaul from north
executables/lte-ru.c:        ru->fh_north_out         = NULL;                    // no outgoing fronthaul to north
executables/lte-ru.c:        ru->start_if             = NULL;                    // no if interface
executables/lte-ru.c:        ru->rfdevice.host_type   = RAU_HOST;
executables/lte-ru.c:        ru->start_write_thread     = start_write_thread;
executables/lte-ru.c:      ru->fh_south_in            = rx_rf;                               // local synchronous RF RX
executables/lte-ru.c:      ru->fh_south_out           = tx_rf;                               // local synchronous RF TX
executables/lte-ru.c:      ru->start_rf               = start_rf;                            // need to start the local RF interface
executables/lte-ru.c:      ru->stop_rf                = stop_rf;
executables/lte-ru.c:      LOG_I(PHY,"NFGI_RRU_IF4p5: configuring ru_id %d (start_rf %p)\n", ru->idx, start_rf);
executables/lte-ru.c:        if (ru->function == eNodeB_3GPP) { // configure RF parameters only for 3GPP eNodeB, we need to get them from RAU otherwise
executables/lte-ru.c:        init_frame_parms(&ru->frame_parms,1);
executables/lte-ru.c:        ret = openair0_device_load(&ru->rfdevice,&ru->openair0_cfg);
executables/lte-ru.c:      ru->do_prach               = 0;
executables/lte-ru.c:      ru->feprx                  = (get_thread_worker_conf() == WORKER_DISABLE) ? fep_full : fep_full;             // this is frequency-shift + DFTs
executables/lte-ru.c:      ru->feptx_prec             = feptx_prec;                                                                     // need to do transmit Precoding + IDFTs
executables/lte-ru.c:      ru->feptx_ofdm             = (get_thread_worker_conf() == WORKER_DISABLE) ? feptx_ofdm : feptx_ofdm_2thread; // need to do transmit Precoding + IDFTs
executables/lte-ru.c:      if (ru->if_timing == synch_to_other) {
executables/lte-ru.c:        ru->fh_south_in          = fh_slave_south_in;                  // synchronize to master
executables/lte-ru.c:        ru->fh_south_in          = fh_if5_south_in;     // synchronous IF5 reception
executables/lte-ru.c:        ru->fh_south_out         = fh_if5_south_out;    // synchronous IF5 transmission
executables/lte-ru.c:        ru->fh_south_asynch_in   = NULL;                // no asynchronous UL
executables/lte-ru.c:      ru->start_rf               = ru->eth_params.transp_preference == ETH_UDP_IF5_ECPRI_MODE ? start_streaming : NULL;
executables/lte-ru.c:      ru->stop_rf                = NULL;
executables/lte-ru.c:      ru->start_if               = start_if;             // need to start if interface for IF5
executables/lte-ru.c:      ru->ifdevice.host_type     = RAU_HOST;
executables/lte-ru.c:      ru->ifdevice.eth_params    = &ru->eth_params;
executables/lte-ru.c:      ru->ifdevice.configure_rru = configure_ru;
executables/lte-ru.c:      ret = openair0_transport_load(&ru->ifdevice,&ru->openair0_cfg,&ru->eth_params);
executables/lte-ru.c:      LOG_I(PHY,"REMOTE_IF5: openair0_transport_init returns %d for ru_id %d\n", ret, ru->idx);
executables/lte-ru.c:      ru->do_prach               = 0;
executables/lte-ru.c:      ru->feprx                  = NULL;                // DFTs
executables/lte-ru.c:      ru->feptx_prec             = feptx_prec;          // Precoding operation
executables/lte-ru.c:      ru->feptx_ofdm             = NULL;                // no OFDM mod
executables/lte-ru.c:      ru->fh_south_in            = fh_if4p5_south_in;   // synchronous IF4p5 reception
executables/lte-ru.c:      ru->fh_south_out           = fh_if4p5_south_out;  // synchronous IF4p5 transmission
executables/lte-ru.c:      ru->fh_south_asynch_in     = (ru->if_timing == synch_to_other) ? fh_if4p5_south_in : NULL;                // asynchronous UL if synch_to_other
executables/lte-ru.c:      ru->fh_north_out           = NULL;
executables/lte-ru.c:      ru->fh_north_asynch_in     = NULL;
executables/lte-ru.c:      ru->start_rf               = NULL;                // no local RF
executables/lte-ru.c:      ru->stop_rf                = NULL;
executables/lte-ru.c:      ru->start_if               = start_if;            // need to start if interface for IF4p5
executables/lte-ru.c:      ru->ifdevice.host_type     = RAU_HOST;
executables/lte-ru.c:      ru->ifdevice.eth_params    = &ru->eth_params;
executables/lte-ru.c:      ru->ifdevice.configure_rru = configure_ru;
executables/lte-ru.c:      ret = openair0_transport_load(&ru->ifdevice, &ru->openair0_cfg, &ru->eth_params);
executables/lte-ru.c:      LOG_I(PHY,"REMOTE IF4p5: openair0_transport_init returns %d for ru_id %d\n", ret, ru->idx);
executables/lte-ru.c:      if (ru->ifdevice.get_internal_parameter != NULL) {
executables/lte-ru.c:        void *t = ru->ifdevice.get_internal_parameter("fh_if4p5_south_in");
executables/lte-ru.c:          ru->fh_south_in = t;
executables/lte-ru.c:        t = ru->ifdevice.get_internal_parameter("fh_if4p5_south_out");
executables/lte-ru.c:          ru->fh_south_out = t;
executables/lte-ru.c:      LOG_E(PHY,"RU with invalid or unknown southbound interface type %d\n",ru->if_south);
executables/lte-ru.c:  ru->rf_config_file = rf_config_file;
executables/lte-ru.c:  ru->idx            = ru_id;
executables/lte-ru.c:  ru->ts_offset      = 0;
executables/lte-ru.c:  if (ru->is_slave == 1) {
executables/lte-ru.c:    ru->in_synch = 0;
executables/lte-ru.c:    ru->generate_dmrs_sync = 0;
executables/lte-ru.c:    ru->in_synch = 1;
executables/lte-ru.c:    ru->generate_dmrs_sync = send_dmrssync;
executables/lte-ru.c:  ru->cmd = EMPTY;
executables/lte-ru.c:  ru->south_out_cnt = 0;
executables/lte-ru.c:  //ru->generate_dmrs_sync = (ru->is_slave == 0) ? 1 : 0;
executables/lte-ru.c:  if ((ru->is_slave == 0) && (ru->ota_sync_enable == 1))
executables/lte-ru.c:    ru->generate_dmrs_sync = 1;
executables/lte-ru.c:    ru->generate_dmrs_sync = 0;
executables/lte-ru.c:  ru->wakeup_L1_sleeptime = 2000;
executables/lte-ru.c:  ru->wakeup_L1_sleep_cnt_max  = 3;
executables/lte-ru.c:    ru->ru0 = rup[0];
executables/lte-ru.c:    if (ru->num_eNB > 0) {
executables/lte-ru.c:      LOG_D(PHY, "%s() ru[%d].num_eNB:%d ru->eNB_list[0]:%p eNB[0][0]:%p rf_config_file:%s\n", __FUNCTION__, ru_id, ru->num_eNB, ru->eNB_list[0], eNBp[0][0], ru->rf_config_file);
executables/lte-ru.c:      if (ru->eNB_list[0] == 0) {
executables/lte-ru.c:	LOG_E(PHY,"%s() DJP - ru->eNB_list ru->num_eNB are not initialized - so do it manually\n", __FUNCTION__);
executables/lte-ru.c:	ru->eNB_list[0] = eNBp[0][0];
executables/lte-ru.c:        ru->num_eNB=1;
executables/lte-ru.c:    eNB0 = ru->eNB_list[0];
executables/lte-ru.c:    fp   = ru->frame_parms;
executables/lte-ru.c:    LOG_D(PHY, "RU FUnction:%d ru->if_south:%d\n", ru->function, ru->if_south);
executables/lte-ru.c:      if ((ru->function != NGFI_RRU_IF5) && (ru->function != NGFI_RRU_IF4p5))
executables/lte-ru.c:        LOG_I(PHY,"Copying frame parms from eNB %d to ru %d\n",eNB0->Mod_id,ru->idx);
executables/lte-ru.c:        ru->frame_parms = &eNB0->frame_parms;
executables/lte-ru.c:        LOG_D(PHY,"ru->num_eNB:%d eNB0->num_RU:%d\n", ru->num_eNB, eNB0->num_RU);
executables/lte-ru.c:        for (i=0; i<ru->num_eNB; i++) {
executables/lte-ru.c:          eNB0 = ru->eNB_list[i];
executables/lte-ru.c:    LOG_I(PHY, "Initializing RRU descriptor %d : (%s,%s,%d)\n", ru_id, ru_if_types[ru->if_south], NB_timing[ru->if_timing], ru->function);
executables/lte-ru.c:    if (ru->function != NGFI_RRU_IF4p5 && ru->function != NGFI_RRU_IF5) {
executables/lte-ru.c:       fill_rf_config(ru,ru->rf_config_file);
executables/lte-ru.c:       init_frame_parms(ru->frame_parms,1);
executables/lte-ru.c:    LOG_I(PHY, "Starting ru_thread %d, is_slave %d, send_dmrs %d\n", ru_id, ru->is_slave, ru->generate_dmrs_sync);
executables/lte-ru.c:    ru->proc.instance_pre_scd = 0;
executables/lte-ru.c:    pthread_cond_signal( &ru->proc.cond_pre_scd );
executables/lte-ru.c:    pthread_join(ru->proc.pthread_pre_scd, (void **)&status );
executables/lte-ru.c:    pthread_mutex_destroy(&ru->proc.mutex_pre_scd );
executables/lte-ru.c:    pthread_cond_destroy(&ru->proc.cond_pre_scd );
executables/lte-ru.c:    ru->proc.instance_cnt_phy_tx = 0;
executables/lte-ru.c:    pthread_cond_signal(&ru->proc.cond_phy_tx);
executables/lte-ru.c:    pthread_join( ru->proc.pthread_phy_tx, (void **)&status );
executables/lte-ru.c:    pthread_mutex_destroy( &ru->proc.mutex_phy_tx );
executables/lte-ru.c:    pthread_cond_destroy( &ru->proc.cond_phy_tx );
executables/lte-ru.c:    ru->proc.instance_cnt_rf_tx = 0;
executables/lte-ru.c:    pthread_cond_signal(&ru->proc.cond_rf_tx);
executables/lte-ru.c:    pthread_join( ru->proc.pthread_rf_tx, (void **)&status );
executables/lte-ru.c:    pthread_mutex_destroy( &ru->proc.mutex_rf_tx );
executables/lte-ru.c:    pthread_cond_destroy( &ru->proc.cond_rf_tx );
executables/lte-ru.c:    //    ru->rf_config_file = rf_config_file;
executables/lte-ru.c:    ru->idx          = ru_id;
executables/lte-ru.c:    ru->ts_offset    = 0;
executables/lte-ru.c:    if (ru->num_eNB > 0) {
executables/lte-ru.c:      //      LOG_D(PHY, "%s() RC.ru[%d].num_eNB:%d ru->eNB_list[0]:%p RC.eNB[0][0]:%p rf_config_file:%s\n", __FUNCTION__, ru_id, ru->num_eNB, ru->eNB_list[0], RC.eNB[0][0], ru->rf_config_file);
executables/lte-ru.c:      if (ru->eNB_list[0] == 0) {
executables/lte-ru.c:        LOG_E(PHY,"%s() DJP - ru->eNB_list ru->num_eNB are not initialized - so do it manually\n", __FUNCTION__);
executables/lte-ru.c:        ru->eNB_list[0] = RC.eNB[0][0];
executables/lte-ru.c:        ru->num_eNB=1;
executables/lte-ru.c:        eNB0             = ru->eNB_list[0];
executables/lte-ru.c:        LOG_D(PHY, "RU FUnction:%d ru->if_south:%d\n", ru->function, ru->if_south);
executables/lte-ru.c:          if ((ru->function != NGFI_RRU_IF5) && (ru->function != NGFI_RRU_IF4p5))
executables/lte-ru.c:            LOG_I(PHY,"Copying frame parms from eNB %d to ru %d\n",eNB0->Mod_id,ru->idx);
executables/lte-ru.c:            memcpy((void*)&ru->frame_parms,(void*)&eNB0->frame_parms,sizeof(LTE_DL_FRAME_PARMS));
executables/lte-ru.c:            LOG_D(PHY,"ru->num_eNB:%d eNB0->num_RU:%d\n", ru->num_eNB, eNB0->num_RU);
executables/lte-ru.c:            for (i=0;i<ru->num_eNB;i++) {
executables/lte-ru.c:              eNB0 = ru->eNB_list[i];
executables/lte-ru.c:    LOG_I(PHY,"Initializing RRU descriptor %d : (%s,%s,%d)\n",ru_id,ru_if_types[ru->if_south],NB_timing[ru->if_timing],ru->function);
executables/lte-ru.c:    proc = &ru->proc;
nfapi/open-nFAPI/README.md:The open-nFAPI implementation has been integrated with the Open Air Interface solution here (https://gitlab.eurecom.fr/oai/openairinterface5g) and is (at the time of writing) here (https://gitlab.eurecom.fr/daveprice/openairinterface5g/tree/nfapi-ru-rau-split). The open-nFAPI implementation is integrated with the source eNB implementation with any changes required applied as a patch on top of the baseline open-nFAPI library. Any extensions required must be implemented through the vendor extensions as specified by the Small Cell Forum documentation. Any integration wrapping of functionality must be done within the target environment as shown in the Open Air Interface implementation nfapi directory which is defined by the $NFAPI_DIR location at the top level.
radio/ETHERNET/benetel/4g/benetel.c:  benetel_eth_state_t *s = ru->ifdevice.priv;
radio/ETHERNET/benetel/4g/benetel.c:  PHY_VARS_eNB **eNB_list = ru->eNB_list, *eNB;
radio/ETHERNET/benetel/4g/benetel.c:    out = (uint16_t *)ru->prach_rxsigF[0][antenna];
radio/ETHERNET/benetel/4g/benetel.c:    ru->wakeup_prach_eNB(ru->eNB_list[0], ru, *frame, *subframe);
radio/ETHERNET/benetel/4g/benetel.c:  for (antenna = 0; antenna < ru->nb_rx; antenna++) {
radio/ETHERNET/benetel/4g/benetel.c:      rxdata = &ru->common.rxdataF[antenna][symbol * fp->ofdm_symbol_size];
radio/ETHERNET/benetel/4g/benetel.c:  RU_proc_t *proc = &ru->proc;
radio/ETHERNET/benetel/4g/benetel.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_IF4P5_SOUTH_IN_RU+ru->idx,f);
radio/ETHERNET/benetel/4g/benetel.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_IF4P5_SOUTH_IN_RU+ru->idx,sf);
radio/ETHERNET/benetel/4g/benetel.c:  benetel_eth_state_t *s = ru->ifdevice.priv;
radio/ETHERNET/benetel/4g/benetel.c:  PHY_VARS_eNB **eNB_list = ru->eNB_list, *eNB;
radio/ETHERNET/benetel/4g/benetel.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TST, ru->proc.timestamp_tx&0xffffffff );
radio/ETHERNET/benetel/4g/benetel.c:  if (ru->num_eNB != 1 || fp->ofdm_symbol_size != 2048 ||
radio/ETHERNET/benetel/4g/benetel.c:  for (aa = 0; aa < ru->nb_tx; aa++) {
radio/ETHERNET/benetel/4g/benetel.c:      txdata = &ru->common.txdataF_BF[aa][symbol * fp->ofdm_symbol_size];
radio/ETHERNET/benetel/4g/benetel.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_FRAME_NUMBER_IF4P5_SOUTH_OUT_RU+ru->idx, ru->proc.frame_tx);
radio/ETHERNET/benetel/4g/benetel.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_SUBFRAME_NUMBER_IF4P5_SOUTH_OUT_RU+ru->idx, ru->proc.tti_tx);
radio/ETHERNET/benetel/5g/benetel.c:  benetel_eth_state_t *s = ru->ifdevice.priv;
radio/ETHERNET/benetel/5g/benetel.c:    out = (uint16_t *)ru->prach_rxsigF[0][antenna];
radio/ETHERNET/benetel/5g/benetel.c:    //ru->wakeup_prach_gNB(ru->gNB_list[0], ru, *frame, *slot);
radio/ETHERNET/benetel/5g/benetel.c:  fp = ru->nr_frame_parms;
radio/ETHERNET/benetel/5g/benetel.c:  for (antenna = 0; antenna < ru->nb_rx; antenna++) {
radio/ETHERNET/benetel/5g/benetel.c:      rxdata = &ru->common.rxdataF[antenna][symbol * fp->ofdm_symbol_size];
radio/ETHERNET/benetel/5g/benetel.c:printf("rxdata in benetel_fh_if4p5_south_in %p\n", &ru->common.rxdataF[antenna][0]);
radio/ETHERNET/benetel/5g/benetel.c:  RU_proc_t *proc = &ru->proc;
radio/ETHERNET/benetel/5g/benetel.c:    proc->tti_tx   = (sl+ru->sl_ahead)%20;
radio/ETHERNET/benetel/5g/benetel.c:    proc->frame_tx = (sl>(19-ru->sl_ahead)) ? (f+1)&1023 : f;
radio/ETHERNET/benetel/5g/benetel.c:  benetel_eth_state_t *s = ru->ifdevice.priv;
radio/ETHERNET/benetel/5g/benetel.c:  fp = ru->nr_frame_parms;
radio/ETHERNET/benetel/5g/benetel.c:  if (ru->num_gNB != 1 || fp->ofdm_symbol_size != 2048 ||
radio/ETHERNET/benetel/5g/benetel.c:  for (aa = 0; aa < ru->nb_tx; aa++) {
radio/ETHERNET/benetel/5g/benetel.c:      txdata = &ru->common.txdataF_BF[aa][symbol * fp->ofdm_symbol_size];
docker/Dockerfile.lteRU.rhel9:FROM ran-base:latest AS ru-base
docker/Dockerfile.lteRU.rhel9:FROM ran-build:latest AS ru-build
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-build \
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-build \
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-base \
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-base /usr/local/bin/uhd_find_devices /usr/local/bin
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-base /usr/local/lib64/libuhd.so.4.4.0 /usr/local/lib64
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-base /usr/local/lib64/uhd/utils/uhd_images_downloader.py /opt/oai-lte-ru/bin
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-base /usr/local/share/uhd/rfnoc/ .
docker/Dockerfile.lteRU.rhel9:COPY --from=ru-base /tini /tini
docker/Dockerfile.lteRU.ubuntu22:FROM ran-base:latest AS ru-base
docker/Dockerfile.lteRU.ubuntu22:FROM ran-build:latest AS ru-build
docker/Dockerfile.lteRU.ubuntu22:COPY --from=ru-build \
docker/Dockerfile.lteRU.ubuntu22:COPY --from=ru-build \
docker/Dockerfile.lteRU.ubuntu22:COPY --from=ru-base /usr/local/bin/uhd_find_devices /usr/local/bin
docker/Dockerfile.lteRU.ubuntu22:COPY --from=ru-base /usr/local/lib/libuhd.so.4.4.0 /usr/local/lib
docker/Dockerfile.lteRU.ubuntu22:COPY --from=ru-base /usr/local/lib/uhd/utils/uhd_images_downloader.py /opt/oai-lte-ru/bin
docker/Dockerfile.lteRU.ubuntu22:COPY --from=ru-base \
docker/Dockerfile.lteRU.ubuntu22:COPY --from=ru-base /tini /tini
radio/fhi_72/oaioran.c:      struct xran_fh_config *fh_config = &xran_ctx_per_ru->fh_cfg;
radio/fhi_72/oaioran.c:          struct xran_prb_map *pRbMap = (struct xran_prb_map *)xran_ctx_per_ru->sFrontHaulRxPrbMapBbuIoBufCtrl[tti % XRAN_N_FE_BUF_LEN][cc_id][ant_id].sBufferList.pBuffers->pData;
radio/fhi_72/oaioran.c:  int nb_rx_per_ru = ru->nb_rx / xran_ctx->fh_init.xran_ports;
radio/fhi_72/oaioran.c:      for (int aa = 0; aa < ru->nb_rx; aa++) {
radio/fhi_72/oaioran.c:        dst = ru->prach_buf[aa]; // + (sym_idx*576));
radio/fhi_72/oaioran.c:  uint8_t *rx_data = (uint8_t *)ru->rxdataF[0];
radio/fhi_72/oaioran.c:  int nb_rx_per_ru = ru->nb_rx / fh_init->xran_ports;
radio/fhi_72/oaioran.c:    for (uint8_t ant_id = 0; ant_id < ru->nb_rx; ant_id++) {
radio/fhi_72/oaioran.c:      rx_data = (uint8_t *)ru->rxdataF[ant_id];
radio/fhi_72/oaioran.c:      for (int rxant = 0; rxant < ru->nb_rx / fh_init->xran_ports; rxant++)
radio/fhi_72/oaioran.c:  int nb_tx_per_ru = ru->nb_tx / fh_init->xran_ports;
radio/fhi_72/oaioran.c:    for (uint8_t ant_id = 0; ant_id < ru->nb_tx; ant_id++) {
radio/fhi_72/oaioran.c:        pos = &ru->txdataF_BF[ant_id][sym_idx * fftsize];
targets/DOCS/oai_L1_L2_procedures.ipe:{\tt openair1/SCHED/ru-procedures.c}
targets/DOCS/oai_L1_L2_procedures.ipe:{\tt openair1/SCHED/ru-procedures.c}
targets/DOCS/oai_L1_L2_procedures.ipe:{\tt openair1/SCHED/ru-procedures.c}
radio/fhi_72/mplane/ru-mplane-api.c:#include "ru-mplane-api.h"
radio/fhi_72/mplane/yang/get-yang.h:#include "../ru-mplane-api.h"
radio/fhi_72/mplane/yang/create-yang-config.h:#include "../ru-mplane-api.h"
executables/nr-ru.c:    LOG_D(PHY, "Sending RAU tick to RRU %d\n", ru->idx);
executables/nr-ru.c:    AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/nr-ru.c:                "RU %d cannot access remote radio\n",ru->idx);
executables/nr-ru.c:    if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/nr-ru.c:      LOG_D(PHY, "Waiting for RRU %d\n", ru->idx);
executables/nr-ru.c:      LOG_I(PHY,"Received capabilities from RRU %d (len %d/%d, num_bands %d,max_pdschReferenceSignalPower %d, max_rxgain %d, nb_tx %d, nb_rx %d)\n",ru->idx,
executables/nr-ru.c:      LOG_E(PHY,"Received incorrect message %d from RRU %d\n",rru_config_msg.type,ru->idx);
executables/nr-ru.c:  LOG_I(PHY,"Sending Configuration to RRU %d (num_bands %d,band0 %d,txfreq %u,rxfreq %u,att_tx %d,att_rx %d,N_RB_DL %d,N_RB_UL %d,3/4FS %d, prach_FO %d, prach_CI %d)\n",ru->idx,
executables/nr-ru.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/nr-ru.c:              "RU %d failed send configuration to remote radio\n",ru->idx);
executables/nr-ru.c:  if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/nr-ru.c:    LOG_I(PHY,"Waiting for RRU %d\n",ru->idx);
executables/nr-ru.c:    LOG_E(PHY,"Received incorrect message %d from RRU %d\n",rru_config_msg.type,ru->idx);
executables/nr-ru.c:    if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/nr-ru.c:        (int)rru_config_msg.len,ru->num_bands,ru->max_pdschReferenceSignalPower,ru->max_rxgain,ru->nb_tx,ru->nb_rx);
executables/nr-ru.c:  switch (ru->function) {
executables/nr-ru.c:  cap->num_bands                                  = ru->num_bands;
executables/nr-ru.c:  for (i=0; i<ru->num_bands; i++) {
executables/nr-ru.c:          ru->band[i],ru->nb_rx,ru->nb_tx,ru->max_pdschReferenceSignalPower,ru->max_rxgain);
executables/nr-ru.c:    cap->band_list[i]                             = ru->band[i];
executables/nr-ru.c:    cap->nb_rx[i]                                 = ru->nb_rx;
executables/nr-ru.c:    cap->nb_tx[i]                                 = ru->nb_tx;
executables/nr-ru.c:    cap->max_pdschReferenceSignalPower[i]         = ru->max_pdschReferenceSignalPower;
executables/nr-ru.c:    cap->max_rxgain[i]                            = ru->max_rxgain;
executables/nr-ru.c:  AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice,&rru_config_msg,rru_config_msg.len)!=-1),
executables/nr-ru.c:              "RU %d failed send capabilities to RAU\n",ru->idx);
executables/nr-ru.c:    if ((len = ru->ifdevice.trx_ctlrecv_func(&ru->ifdevice,
executables/nr-ru.c:  if (ru == RC.ru[0]) VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TST, ru->proc.timestamp_tx&0xffffffff );
executables/nr-ru.c:  int offset = ru->nr_frame_parms->get_samples_slot_timestamp(slot,ru->nr_frame_parms,0);
executables/nr-ru.c:  void *buffs[ru->nb_tx]; 
executables/nr-ru.c:  for (int aid=0;aid<ru->nb_tx;aid++) buffs[aid] = (void*)&ru->common.txdata[aid][offset]; 
executables/nr-ru.c:  10*log10((double)signal_energy(buffs[0],ru->nr_frame_parms->get_samples_per_slot(slot,ru->nr_frame_parms))),(int)txmeas.tv_nsec);
executables/nr-ru.c:  ru->ifdevice.trx_write_func2(&ru->ifdevice,
executables/nr-ru.c:			       ru->nr_frame_parms->get_samples_per_slot(slot,ru->nr_frame_parms),
executables/nr-ru.c:			       ru->nb_tx); 
executables/nr-ru.c:  nfapi_nr_config_request_scf_t *cfg = &ru->config;
executables/nr-ru.c:  if (ru == RC.ru[0]) VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TST, ru->proc.timestamp_tx&0xffffffff );
executables/nr-ru.c:  LOG_D(PHY,"Sending IF4p5 for frame %d subframe %d\n",ru->proc.frame_tx,ru->proc.tti_tx);
executables/nr-ru.c:  if ((nr_slot_select(cfg,ru->proc.frame_tx,ru->proc.tti_tx)&NR_DOWNLINK_SLOT) > 0)
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  RU_proc_t *proc = &ru->proc;
executables/nr-ru.c:  start_meas(&ru->rx_fhaul);
executables/nr-ru.c:  ru->ifdevice.trx_read_func2(&ru->ifdevice,&proc->timestamp_rx,NULL,fp->get_samples_per_slot(*tti,fp)); 
executables/nr-ru.c:  if (proc->first_rx == 1) ru->ts_offset = proc->timestamp_rx;
executables/nr-ru.c:  proc->frame_rx    = ((proc->timestamp_rx-ru->ts_offset) / (fp->samples_per_subframe*10))&1023;
executables/nr-ru.c:  proc->tti_rx = fp->get_slot_from_timestamp(proc->timestamp_rx-ru->ts_offset,fp);
executables/nr-ru.c:  stop_meas(&ru->rx_fhaul);
executables/nr-ru.c:  double fhtime = ru->rx_fhaul.p_time/(cpu_freq_GHz*1000.0);
executables/nr-ru.c:  if (fhtime > 800) LOG_W(PHY,"IF5 %d.%d => RX %d.%d first_rx %d: time %f, rxstart %d\n",*frame,*tti,proc->frame_rx,proc->tti_rx,proc->first_rx,ru->rx_fhaul.p_time/(cpu_freq_GHz*1000.0),(int)rxmeas.tv_nsec);
executables/nr-ru.c:  else LOG_D(PHY,"IF5 %d.%d => RX %d.%d first_rx %d: time %f, rxstart %d\n",*frame,*tti,proc->frame_rx,proc->tti_rx,proc->first_rx,ru->rx_fhaul.p_time/(cpu_freq_GHz*1000.0),(int)rxmeas.tv_nsec);
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  RU_proc_t *proc = &ru->proc;
executables/nr-ru.c:  proc->tti_tx   = (sl+ru->sl_ahead)%fp->slots_per_frame;
executables/nr-ru.c:  proc->frame_tx = (sl>(fp->slots_per_frame-1-(ru->sl_ahead))) ? (f+1)&1023 : f;
executables/nr-ru.c:  LOG_D(PHY,"RU %d: fh_if4p5_south_in sleeping ...\n",ru->idx);
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  RU_proc_t *proc       = &ru->proc;
executables/nr-ru.c:  symbol_mask_full = (1<<(ru->nr_frame_parms->symbols_per_slot))-1;
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  RU_proc_t *proc        = &ru->proc;
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  nfapi_nr_config_request_scf_t *cfg = &ru->config;
executables/nr-ru.c:  RU_proc_t *proc        = &ru->proc;
executables/nr-ru.c:    if (((nr_slot_select(cfg,frame_tx,slot_tx) & NR_DOWNLINK_SLOT) > 0) && (symbol_number == 0)) start_meas(&ru->rx_fhaul);
executables/nr-ru.c:  if ((nr_slot_select(cfg,frame_tx,slot_tx) & NR_DOWNLINK_SLOT)>0) stop_meas(&ru->rx_fhaul);
executables/nr-ru.c:  LOG_D(PHY,"RU %d/%d TST %llu, frame %d, subframe %d\n",ru->idx,0,(long long unsigned int)proc->timestamp_tx,frame_tx,slot_tx);
executables/nr-ru.c:  if (ru->feptx_ofdm)
executables/nr-ru.c:    ru->feptx_ofdm(ru, frame_tx, slot_tx);
executables/nr-ru.c:  if (ru->fh_south_out)
executables/nr-ru.c:    ru->fh_south_out(ru, frame_tx, slot_tx, proc->timestamp_tx);
executables/nr-ru.c:  RU_proc_t *proc=&ru->proc;
executables/nr-ru.c:  //NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  if (ru->idx==0) VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TTI_NUMBER_RX0_RU, proc->tti_rx );
executables/nr-ru.c:  start_meas(&ru->tx_fhaul);
executables/nr-ru.c:  stop_meas(&ru->tx_fhaul);
executables/nr-ru.c:  RU_proc_t *proc = &ru->proc;
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  openair0_config_t *cfg   = &ru->openair0_cfg;
executables/nr-ru.c:  void *rxp[ru->nb_rx];
executables/nr-ru.c:  start_meas(&ru->rx_fhaul);
executables/nr-ru.c:  for (i=0; i<ru->nb_rx; i++)
executables/nr-ru.c:    rxp[i] = (void *)&ru->common.rxdata[i][fp->get_samples_slot_timestamp(*slot,fp,0)];
executables/nr-ru.c:    rxs = ru->rfdevice.trx_read_func(&ru->rfdevice,
executables/nr-ru.c:                                     ru->nb_rx);
executables/nr-ru.c:  proc->timestamp_rx = ts-ru->ts_offset;
executables/nr-ru.c:            ru->ts_offset);
executables/nr-ru.c:      ru->ts_offset += (proc->timestamp_rx - old_ts - samples_per_slot_prev);
executables/nr-ru.c:      proc->timestamp_rx = ts-ru->ts_offset;
executables/nr-ru.c:        ru->idx,
executables/nr-ru.c:        ts, //(unsigned long long int)(proc->timestamp_rx+ru->ts_offset),
executables/nr-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TS, (proc->timestamp_rx+ru->ts_offset)&0xffffffff );
executables/nr-ru.c:  stop_meas(&ru->rx_fhaul);
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  openair0_config_t *cfg0 = &ru->openair0_cfg;
executables/nr-ru.c:      if (ru->common.beam_id) {
executables/nr-ru.c:        const int *beam_ids = ru->common.beam_id[0];
executables/nr-ru.c:          LOG_I(HW, "slot %d, beam %d\n", slot, ru->common.beam_id[0][slot * fp->symbols_per_slot]);
executables/nr-ru.c:      if ((slot % 10 == 0) && ru->common.beam_id && (ru->common.beam_id[0][slot * fp->symbols_per_slot] < 64)) {
executables/nr-ru.c:        // beam = ru->common.beam_id[0][slot*fp->symbols_per_slot] | 64;
executables/nr-ru.c:  RU_proc_t *proc = &ru->proc;
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  nfapi_nr_config_request_scf_t *cfg = &ru->config;
executables/nr-ru.c:  void *txp[ru->nb_tx];
executables/nr-ru.c:    T_BUFFER(&ru->common.txdata[0][fp->get_samples_slot_timestamp(slot, fp, 0)], fp->get_samples_per_slot(slot, fp) * 4));
executables/nr-ru.c:      //+ ru->end_of_burst_delay;
executables/nr-ru.c:        sf_extension = ru->sf_extension;
executables/nr-ru.c:  if (ru->openair0_cfg.gpio_controller != RU_GPIO_CONTROL_NONE)
executables/nr-ru.c:  for (i = 0; i < ru->nb_tx; i++)
executables/nr-ru.c:    txp[i] = (void *)&ru->common.txdata[i][fp->get_samples_slot_timestamp(slot, fp, 0)] - sf_extension * sizeof(int32_t);
executables/nr-ru.c:  VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_TRX_TST, (timestamp + ru->ts_offset) & 0xffffffff);
executables/nr-ru.c:  uint32_t txs = ru->rfdevice.trx_write_func(&ru->rfdevice,
executables/nr-ru.c:                                             timestamp + ru->ts_offset - sf_extension,
executables/nr-ru.c:                                             ru->nb_tx, flags);
executables/nr-ru.c:        ru->idx,
executables/nr-ru.c:        (long long unsigned int)(timestamp + ru->ts_offset - sf_extension),
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp   = ru->nr_frame_parms;
executables/nr-ru.c:  nfapi_nr_config_request_scf_t *config = &ru->config; //tmp index
executables/nr-ru.c:  openair0_config_t *cfg   = &ru->openair0_cfg;
executables/nr-ru.c:  AssertFatal(ru->nb_tx > 0 && ru->nb_tx <= 8, "openair0 does not support more than 8 antennas\n");
executables/nr-ru.c:  AssertFatal(ru->nb_rx > 0 && ru->nb_rx <= 8, "openair0 does not support more than 8 antennas\n");
executables/nr-ru.c:  cfg->tx_num_channels=ru->nb_tx;
executables/nr-ru.c:  cfg->rx_num_channels=ru->nb_rx;
executables/nr-ru.c:  for (i=0; i<ru->nb_tx; i++) {
executables/nr-ru.c:    if (ru->if_frequency == 0) {
executables/nr-ru.c:    } else if (ru->if_freq_offset) {
executables/nr-ru.c:      cfg->tx_freq[i] = (double)(ru->if_frequency);
executables/nr-ru.c:      LOG_I(PHY, "Setting IF TX frequency to %lu Hz with IF TX frequency offset %d Hz\n", ru->if_frequency, ru->if_freq_offset);
executables/nr-ru.c:      cfg->tx_freq[i] = (double)ru->if_frequency;
executables/nr-ru.c:    cfg->tx_gain[i] = ru->att_tx;
executables/nr-ru.c:  for (i=0; i<ru->nb_rx; i++) {
executables/nr-ru.c:    if (ru->if_frequency == 0) {
executables/nr-ru.c:    } else if (ru->if_freq_offset) {
executables/nr-ru.c:      cfg->rx_freq[i] = (double)(ru->if_frequency + ru->if_freq_offset);
executables/nr-ru.c:      LOG_I(PHY, "Setting IF RX frequency to %lu Hz with IF RX frequency offset %d Hz\n", ru->if_frequency, ru->if_freq_offset);
executables/nr-ru.c:      cfg->rx_freq[i] = (double)(ru->if_frequency+fp->ul_CarrierFreq-fp->dl_CarrierFreq);
executables/nr-ru.c:    cfg->rx_gain[i] = ru->max_rxgain-ru->att_rx;
executables/nr-ru.c:  nfapi_nr_config_request_scf_t *config = &ru->config;
executables/nr-ru.c:    fp = ru->nr_frame_parms;
executables/nr-ru.c:  ru->N_TA_offset = set_default_nta_offset(fp->freq_range, fp->samples_per_subframe);
executables/nr-ru.c:        ru->idx, ru->N_TA_offset, config->carrier_config.uplink_frequency.value, N_RB, mu);
executables/nr-ru.c:  if (ru->openair0_cfg.mmapped_dma == 1) {
executables/nr-ru.c:    for (i=0; i<ru->nb_rx; i++) {
executables/nr-ru.c:      LOG_D(PHY, "Mapping RU id %u, rx_ant %d, on card %d, chain %d\n", ru->idx, i, ru->rf_map.card + card, ru->rf_map.chain + ant);
executables/nr-ru.c:      free(ru->common.rxdata[i]);
executables/nr-ru.c:      ru->common.rxdata[i] = ru->openair0_cfg.rxbase[ru->rf_map.chain + ant];
executables/nr-ru.c:        ru->common.rxdata[i][j] = 16-j;
executables/nr-ru.c:    for (i=0; i<ru->nb_tx; i++) {
executables/nr-ru.c:      LOG_D(PHY, "Mapping RU id %u, tx_ant %d, on card %d, chain %d\n", ru->idx, i, ru->rf_map.card + card, ru->rf_map.chain + ant);
executables/nr-ru.c:      free(ru->common.txdata[i]);
executables/nr-ru.c:      ru->common.txdata[i] = ru->openair0_cfg.txbase[ru->rf_map.chain + ant];
executables/nr-ru.c:        ru->common.txdata[i][j] = 16-j;
executables/nr-ru.c:      if (ru->feprx) print_meas(&ru->ofdm_demod_stats,"feprx (all ports)",NULL,NULL);
executables/nr-ru.c:      if (ru->feptx_ofdm) {
executables/nr-ru.c:        print_meas(&ru->precoding_stats,(ru->half_slot_parallelization==0)?"feptx_prec (per port)":"feptx_prec (per port, half_slot)",NULL,NULL);
executables/nr-ru.c:        print_meas(&ru->ofdm_mod_stats,(ru->half_slot_parallelization==0)?"feptx_ofdm (per port)":"feptx_ofdm (per port, half_slot)",NULL,NULL);
executables/nr-ru.c:        print_meas(&ru->txdataF_copy_stats,"txdataF_copy",NULL,NULL);
executables/nr-ru.c:        print_meas(&ru->ofdm_total_stats,"feptx_total",NULL,NULL);
executables/nr-ru.c:      print_meas(&ru->rx_fhaul,"rx_fhaul",NULL,NULL);
executables/nr-ru.c:      if (ru->if_south == REMOTE_IF5) print_meas(&ru->ifdevice.tx_fhaul,"tx_fhaul (IF5)",NULL,NULL); 
executables/nr-ru.c:      else print_meas(&ru->tx_fhaul,"tx_fhaul",NULL,NULL);
executables/nr-ru.c:      if (ru->fh_north_out) {
executables/nr-ru.c:        print_meas(&ru->compression,"compression",NULL,NULL);
executables/nr-ru.c:        print_meas(&ru->transport,"transport",NULL,NULL);
executables/nr-ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
executables/nr-ru.c:  if (ru->feptx_prec)
executables/nr-ru.c:    ru->feptx_prec(ru,frame_tx,slot_tx);
executables/nr-ru.c:  if ((ru->fh_north_asynch_in == NULL) && (ru->feptx_ofdm))
executables/nr-ru.c:    ru->feptx_ofdm(ru, frame_tx, slot_tx);
executables/nr-ru.c:    if ((ru->fh_north_asynch_in == NULL) && (ru->fh_south_out))
executables/nr-ru.c:      ru->fh_south_out(ru, frame_tx, slot_tx, info->timestamp_tx);
executables/nr-ru.c:    if (ru->fh_north_out)
executables/nr-ru.c:      ru->fh_north_out(ru);
executables/nr-ru.c:      for (int i=0; i<ru->nb_tx; i++) {
executables/nr-ru.c:          LOG_M(filename,"txdataF_frame",&ru->gNB_list[0]->common_vars.txdataF[i][0],fp->samples_per_frame_wCP, 1, 1);
executables/nr-ru.c:          LOG_M(filename,"txdataF_frame",&ru->common.txdataF[i][0],fp->samples_per_frame_wCP, 1, 1);
executables/nr-ru.c:          LOG_M(filename,"txdataF_BF_frame",&ru->common.txdataF_BF[i][0],fp->samples_per_subframe_wCP, 1, 1);
executables/nr-ru.c:          LOG_M(filename,"txdata_frame",&ru->common.txdata[i][0],fp->samples_per_frame, 1, 1);
executables/nr-ru.c:            fwrite(&ru->common.txdata[i][0],
executables/nr-ru.c:      }//for (i=0; i<ru->nb_tx; i++)
executables/nr-ru.c:  RU_proc_t          *proc    = &ru->proc;
executables/nr-ru.c:  NR_DL_FRAME_PARMS  *fp      = ru->nr_frame_parms;
executables/nr-ru.c:  sprintf(threadname,"ru_thread %u",ru->idx);
executables/nr-ru.c:  LOG_I(PHY,"Starting RU %d (%s,%s) on cpu %d\n",ru->idx,NB_functions[ru->function],NB_timing[ru->if_timing],sched_getcpu());
executables/nr-ru.c:  memcpy((void *)&ru->config,(void *)&RC.gNB[0]->gNB_config,sizeof(ru->config));
executables/nr-ru.c:  nr_init_frame_parms(&ru->config, fp);
executables/nr-ru.c:  fill_rf_config(ru, ru->rf_config_file);
executables/nr-ru.c:  fill_split7_2_config(&ru->openair0_cfg.split7, &ru->config, fp->slots_per_frame, fp->ofdm_symbol_size);
executables/nr-ru.c:    if (ru->nr_start_if) {
executables/nr-ru.c:      ret = openair0_transport_load(&ru->ifdevice, &ru->openair0_cfg, &ru->eth_params);
executables/nr-ru.c:      AssertFatal(ret == 0, "RU %u: openair0_transport_init() ret %d: cannot initialize transport protocol\n", ru->idx, ret);
executables/nr-ru.c:      if (ru->ifdevice.get_internal_parameter != NULL) {
executables/nr-ru.c:        void *t = ru->ifdevice.get_internal_parameter("fh_if4p5_south_in");
executables/nr-ru.c:          ru->fh_south_in = t;
executables/nr-ru.c:        t = ru->ifdevice.get_internal_parameter("fh_if4p5_south_out");
executables/nr-ru.c:          ru->fh_south_out = t;
executables/nr-ru.c:      if (ru->ru_thread_core > -1 && cpu != ru->ru_thread_core) {
executables/nr-ru.c:        CPU_SET(ru->ru_thread_core, &cpuset);
executables/nr-ru.c:        LOG_I(PHY, "RU %d: manually set CPU affinity to CPU %d\n", ru->idx, ru->ru_thread_core);
executables/nr-ru.c:      LOG_I(PHY,"Starting IF interface for RU %d, nb_rx %d\n",ru->idx,ru->nb_rx);
executables/nr-ru.c:      AssertFatal(ru->nr_start_if(ru,NULL) == 0, "Could not start the IF device\n");
executables/nr-ru.c:      if (ru->has_ctrl_prt > 0) {
executables/nr-ru.c:        if (ru->if_south == LOCAL_RF) ret = connect_rau(ru);
executables/nr-ru.c:    else if (ru->if_south == LOCAL_RF) { // configure RF parameters only
executables/nr-ru.c:      ret = openair0_device_load(&ru->rfdevice,&ru->openair0_cfg);
executables/nr-ru.c:  LOG_I(PHY, "Signaling main thread that RU %d is ready, sl_ahead %d\n",ru->idx,ru->sl_ahead);
executables/nr-ru.c:  RC.ru_mask &= ~(1<<ru->idx);
executables/nr-ru.c:    if (ru->start_rf) {
executables/nr-ru.c:      if (ru->start_rf(ru) != 0)
executables/nr-ru.c:      else LOG_I(PHY,"RU %d rf device ready\n",ru->idx);
executables/nr-ru.c:    } else LOG_I(PHY,"RU %d no rf device\n",ru->idx);
executables/nr-ru.c:    LOG_I(PHY, "RU %d RF started cpu_meas_enabled %d\n", ru->idx, cpu_meas_enabled);
executables/nr-ru.c:      if (ru->start_write_thread) {
executables/nr-ru.c:        if(ru->start_write_thread(ru) != 0) {
executables/nr-ru.c:    if (ru->fh_south_in) ru->fh_south_in(ru,&frame,&slot); //rx_rf call here
executables/nr-ru.c:        LOG_D(PHY, "delay processing to let RX stream settle, frame %d (trials %d)\n", proc->frame_rx, ru->rx_fhaul.trials);
executables/nr-ru.c:        print_meas(&ru->rx_fhaul, "rx_fhaul", NULL, NULL);
executables/nr-ru.c:        reset_meas(&ru->rx_fhaul);
executables/nr-ru.c:    if (initial_wait == 0 && ru->rx_fhaul.trials > 1000) {
executables/nr-ru.c:        reset_meas(&ru->rx_fhaul);
executables/nr-ru.c:        reset_meas(&ru->tx_fhaul);
executables/nr-ru.c:    for (int i = proc->tti_rx; i < proc->tti_rx + ru->sl_ahead; i++)
executables/nr-ru.c:    proc->tti_tx = (proc->tti_rx + ru->sl_ahead) % fp->slots_per_frame;
executables/nr-ru.c:    if (ru->idx != 0)
executables/nr-ru.c:    int slot_type = nr_slot_select(&ru->config, proc->frame_rx, proc->tti_rx);
executables/nr-ru.c:      if (ru->feprx) {
executables/nr-ru.c:        ru->feprx(ru,proc->tti_rx);
executables/nr-ru.c:        //LOG_M("rxdata.m","rxs",ru->common.rxdata[0],1228800,1,1);
executables/nr-ru.c:                     ru->common.rxdataF[0],
executables/nr-ru.c:            T_BUFFER(&ru->common.rxdata[0][fp->get_samples_slot_timestamp(proc->tti_rx - 1, fp, 0) /*-ru->N_TA_offset*/],
executables/nr-ru.c:          RU_PRACH_list_t *p = ru->prach_list + prach_id;
executables/nr-ru.c:      } // end if (ru->feprx)
executables/nr-ru.c:  return(ru->ifdevice.thirdparty_startstreaming(&ru->ifdevice));
executables/nr-ru.c:  if (ru->if_south <= REMOTE_IF5)
executables/nr-ru.c:    for (int i=0;i<ru->nb_rx;i++) ru->openair0_cfg.rxbase[i] = ru->common.rxdata[i];
executables/nr-ru.c:  ru->openair0_cfg.rxsize = ru->nr_frame_parms->samples_per_subframe*10;
executables/nr-ru.c:  reset_meas(&ru->ifdevice.tx_fhaul);
executables/nr-ru.c:  return(ru->ifdevice.trx_start_func(&ru->ifdevice));
executables/nr-ru.c:  return(ru->rfdevice.trx_start_func(&ru->rfdevice));
executables/nr-ru.c:  ru->rfdevice.trx_end_func(&ru->rfdevice);
executables/nr-ru.c:  return(ru->rfdevice.trx_write_init(&ru->rfdevice));
executables/nr-ru.c:  proc = &ru->proc;
executables/nr-ru.c:    threadCreate(&ru->ru_stats_thread, ru_stats_thread, (void *)ru, "ru_stats", -1, OAI_PRIORITY_RT);
executables/nr-ru.c:  LOG_I(PHY, "Initialized RU proc %d (%s,%s),\n", ru->idx, NB_functions[ru->function], NB_timing[ru->if_timing]);
executables/nr-ru.c:  threadCreate(&ru->proc.pthread_FH, ru_thread, (void *)ru, "ru_thread", ru->ru_thread_core, OAI_PRIORITY_RT_MAX);
executables/nr-ru.c:  RU_proc_t *proc = &ru->proc;
executables/nr-ru.c:  if (ru->if_south != REMOTE_IF4p5) {
executables/nr-ru.c:    abortTpool(ru->threadPool);
executables/nr-ru.c:    abortNotifiedFIFO(ru->respfeprx);
executables/nr-ru.c:    abortNotifiedFIFO(ru->respfeptx);
executables/nr-ru.c:    pthread_join(ru->ru_stats_thread, NULL);
executables/nr-ru.c:  if (ru->stop_rf == NULL) {
executables/nr-ru.c:    LOG_W(PHY, "No stop_rf() for RU %d defined, cannot stop RF!\n", ru->idx);
executables/nr-ru.c:  int rc = ru->stop_rf(ru);
executables/nr-ru.c:    LOG_W(PHY, "stop_rf() returned %d, RU %d RF device did not stop properly!\n", rc, ru->idx);
executables/nr-ru.c:  LOG_I(PHY, "RU %d RF device stopped\n",ru->idx);
executables/nr-ru.c:  LOG_I(PHY,"RRU %d, num_bands %d, looking for band %d\n",ru->idx,cap->num_bands,ru->nr_frame_parms->nr_band);
executables/nr-ru.c:    LOG_I(PHY,"band %d on RRU %d\n",cap->band_list[i],ru->idx);
executables/nr-ru.c:    if (ru->nr_frame_parms->nr_band == cap->band_list[i]) {
executables/nr-ru.c:    LOG_I(PHY,"Couldn't find target NR band %d on RRU %d\n",ru->nr_frame_parms->nr_band,ru->idx);
executables/nr-ru.c:  switch (ru->if_south) {
executables/nr-ru.c:      LOG_I(PHY,"No compatible Fronthaul interface found for RRU %d\n", ru->idx);
executables/nr-ru.c:  nfapi_nr_config_request_scf_t *cfg = &ru->config;
executables/nr-ru.c:  LOG_I(PHY, "Received capabilities from RRU %d\n", ru->idx);
executables/nr-ru.c:  AssertFatal(ret == 0, "Cannot configure RRU %d, check_capabilities returned %d\n", ru->idx, ret);
executables/nr-ru.c:  ru->nb_tx                      = capabilities->nb_tx[0];
executables/nr-ru.c:  ru->nb_rx                      = capabilities->nb_rx[0];
executables/nr-ru.c:  LOG_I(PHY, "Using %s fronthaul (%d), band %d \n",ru_if_formats[ru->if_south],ru->if_south,ru->nr_frame_parms->nr_band);
executables/nr-ru.c:  config->FH_fmt                 = ru->if_south;
executables/nr-ru.c:  config->band_list[0]           = ru->nr_frame_parms->nr_band;
executables/nr-ru.c:  config->tx_freq[0]             = ru->nr_frame_parms->dl_CarrierFreq;
executables/nr-ru.c:  config->rx_freq[0]             = ru->nr_frame_parms->ul_CarrierFreq;
executables/nr-ru.c:  //config->tdd_config[0]          = ru->nr_frame_parms->tdd_config;
executables/nr-ru.c:  //config->tdd_config_S[0]        = ru->nr_frame_parms->tdd_config_S;
executables/nr-ru.c:  config->att_tx[0]              = ru->att_tx;
executables/nr-ru.c:  config->att_rx[0]              = ru->att_rx;
executables/nr-ru.c:  config->threequarter_fs[0]     = ru->nr_frame_parms->threequarter_fs;
executables/nr-ru.c:  /*  if (ru->if_south==REMOTE_IF4p5) {
executables/nr-ru.c:      config->prach_FreqOffset[0]  = ru->nr_frame_parms->prach_config_common.prach_ConfigInfo.prach_FreqOffset;
executables/nr-ru.c:      config->prach_ConfigIndex[0] = ru->nr_frame_parms->prach_config_common.prach_ConfigInfo.prach_ConfigIndex;
executables/nr-ru.c:  nr_init_frame_parms(&ru->config, ru->nr_frame_parms);
executables/nr-ru.c:  nfapi_nr_config_request_scf_t *cfg = &ru->config;
executables/nr-ru.c:  ru->nr_frame_parms->nr_band                                             = config->band_list[0];
executables/nr-ru.c:  ru->nr_frame_parms->dl_CarrierFreq                                      = config->tx_freq[0];
executables/nr-ru.c:  ru->nr_frame_parms->ul_CarrierFreq                                      = config->rx_freq[0];
executables/nr-ru.c:  if (ru->nr_frame_parms->dl_CarrierFreq == ru->nr_frame_parms->ul_CarrierFreq) {
executables/nr-ru.c:    //ru->nr_frame_parms->tdd_config                                        = config->tdd_config[0];
executables/nr-ru.c:    //ru->nr_frame_parms->tdd_config_S                                      = config->tdd_config_S[0];
executables/nr-ru.c:  ru->att_tx                                                              = config->att_tx[0];
executables/nr-ru.c:  ru->att_rx                                                              = config->att_rx[0];
executables/nr-ru.c:  ru->nr_frame_parms->threequarter_fs                                     = config->threequarter_fs[0];
executables/nr-ru.c:  //ru->nr_frame_parms->pdsch_config_common.referenceSignalPower                 = ru->max_pdschReferenceSignalPower-config->att_tx[0];
executables/nr-ru.c:  if (ru->function==NGFI_RRU_IF4p5) {
executables/nr-ru.c:    ru->nr_frame_parms->att_rx = ru->att_rx;
executables/nr-ru.c:    ru->nr_frame_parms->att_tx = ru->att_tx;
executables/nr-ru.c:        LOG_I(PHY,"Setting ru->function to NGFI_RRU_IF4p5, prach_FrequOffset %d, prach_ConfigIndex %d, att (%d,%d)\n",
executables/nr-ru.c:        config->prach_FreqOffset[0],config->prach_ConfigIndex[0],ru->att_tx,ru->att_rx);
executables/nr-ru.c:        ru->nr_frame_parms->prach_config_common.prach_ConfigInfo.prach_FreqOffset  = config->prach_FreqOffset[0];
executables/nr-ru.c:        ru->nr_frame_parms->prach_config_common.prach_ConfigInfo.prach_ConfigIndex = config->prach_ConfigIndex[0]; */
executables/nr-ru.c:  fill_rf_config(ru,ru->rf_config_file);
executables/nr-ru.c:  nr_init_frame_parms(&ru->config, ru->nr_frame_parms);
executables/nr-ru.c:  switch (ru->if_south) {
executables/nr-ru.c:      reset_meas(&ru->rx_fhaul);
executables/nr-ru.c:      if (ru->function ==  NGFI_RRU_IF5) {                 // IF5 RRU
executables/nr-ru.c:        ru->do_prach              = 0;                      // no prach processing in RU
executables/nr-ru.c:        ru->fh_north_in           = NULL;                   // no shynchronous incoming fronthaul from north
executables/nr-ru.c:        ru->fh_north_out          = fh_if5_north_out;       // need only to do send_IF5  reception
executables/nr-ru.c:        ru->fh_south_out          = tx_rf;                  // send output to RF
executables/nr-ru.c:        ru->fh_north_asynch_in    = fh_if5_north_asynch_in; // TX packets come asynchronously
executables/nr-ru.c:        ru->feprx                 = NULL;                   // nothing (this is a time-domain signal)
executables/nr-ru.c:        ru->feptx_ofdm            = NULL;                   // nothing (this is a time-domain signal)
executables/nr-ru.c:        ru->feptx_prec            = NULL;                   // nothing (this is a time-domain signal)
executables/nr-ru.c:        ru->nr_start_if           = nr_start_if;            // need to start the if interface for if5
executables/nr-ru.c:        ru->ifdevice.host_type    = RRU_HOST;
executables/nr-ru.c:        ru->rfdevice.host_type    = RRU_HOST;
executables/nr-ru.c:        ru->ifdevice.eth_params   = &ru->eth_params;
executables/nr-ru.c:        reset_meas(&ru->rx_fhaul);
executables/nr-ru.c:        reset_meas(&ru->tx_fhaul);
executables/nr-ru.c:        reset_meas(&ru->compression);
executables/nr-ru.c:        reset_meas(&ru->transport);
executables/nr-ru.c:      } else if (ru->function == NGFI_RRU_IF4p5) {
executables/nr-ru.c:        ru->do_prach              = 1;                        // do part of prach processing in RU
executables/nr-ru.c:        ru->fh_north_in           = NULL;                     // no synchronous incoming fronthaul from north
executables/nr-ru.c:        ru->fh_north_out          = fh_if4p5_north_out;       // send_IF4p5 on reception
executables/nr-ru.c:        ru->fh_south_out          = tx_rf;                    // send output to RF
executables/nr-ru.c:        ru->fh_north_asynch_in    = fh_if4p5_north_asynch_in; // TX packets come asynchronously
executables/nr-ru.c:        ru->feprx                 = nr_fep_tp;     // this is frequency-shift + DFTs
executables/nr-ru.c:        ru->feptx_ofdm            = nr_feptx_tp; // this is fep with idft only (no precoding in RRU)
executables/nr-ru.c:        ru->feptx_prec            = NULL;
executables/nr-ru.c:        ru->nr_start_if           = nr_start_if;              // need to start the if interface for if4p5
executables/nr-ru.c:        ru->ifdevice.host_type    = RRU_HOST;
executables/nr-ru.c:        ru->rfdevice.host_type    = RRU_HOST;
executables/nr-ru.c:        ru->ifdevice.eth_params   = &ru->eth_params;
executables/nr-ru.c:        reset_meas(&ru->tx_fhaul);
executables/nr-ru.c:        reset_meas(&ru->compression);
executables/nr-ru.c:        reset_meas(&ru->transport);
executables/nr-ru.c:      } else if (ru->function == gNodeB_3GPP) {
executables/nr-ru.c:        ru->do_prach             = 0;                       // no prach processing in RU
executables/nr-ru.c:        ru->feprx                = nr_fep_tp;     // this is frequency-shift + DFTs
executables/nr-ru.c:        ru->feptx_ofdm           = nr_feptx_tp;             // this is fep with idft and precoding
executables/nr-ru.c:        ru->feptx_prec           = NULL;                    
executables/nr-ru.c:        ru->fh_north_in          = NULL;                    // no incoming fronthaul from north
executables/nr-ru.c:        ru->fh_north_out         = NULL;                    // no outgoing fronthaul to north
executables/nr-ru.c:        ru->nr_start_if          = NULL;                    // no if interface
executables/nr-ru.c:        ru->rfdevice.host_type   = RAU_HOST;
executables/nr-ru.c:        ru->fh_south_in            = rx_rf;                 // local synchronous RF RX
executables/nr-ru.c:        ru->fh_south_out           = tx_rf;                 // local synchronous RF TX
executables/nr-ru.c:        ru->start_rf               = start_rf;              // need to start the local RF interface
executables/nr-ru.c:        ru->stop_rf                = stop_rf;
executables/nr-ru.c:        ru->start_write_thread     = start_write_thread;                  // starting RF TX in different thread
executables/nr-ru.c:      init_frame_parms(&ru->frame_parms,1);
executables/nr-ru.c:      ret = openair0_device_load(&ru->rfdevice,&ru->openair0_cfg);
executables/nr-ru.c:      ru->do_prach               = 0;
executables/nr-ru.c:      ru->txfh_in_fep            = 0;
executables/nr-ru.c:      ru->feprx                  = nr_fep_tp;     // this is frequency-shift + DFTs
executables/nr-ru.c:      ru->feptx_prec             = NULL;          // need to do transmit Precoding + IDFTs
executables/nr-ru.c:      ru->feptx_ofdm             = nr_feptx_tp; // need to do transmit Precoding + IDFTs
executables/nr-ru.c:      ru->fh_south_in            = fh_if5_south_in;     // synchronous IF5 reception
executables/nr-ru.c:      ru->fh_south_out           = (ru->txfh_in_fep>0) ? NULL : fh_if5_south_out;    // synchronous IF5 transmission
executables/nr-ru.c:      ru->fh_south_asynch_in     = NULL;                // no asynchronous UL
executables/nr-ru.c:      ru->start_rf               = ru->eth_params.transp_preference == ETH_UDP_IF5_ECPRI_MODE ? start_streaming : NULL;
executables/nr-ru.c:      ru->stop_rf                = NULL;
executables/nr-ru.c:      ru->start_write_thread     = NULL;
executables/nr-ru.c:      ru->nr_start_if            = nr_start_if;         // need to start if interface for IF5
executables/nr-ru.c:      ru->ifdevice.host_type     = RAU_HOST;
executables/nr-ru.c:      ru->ifdevice.eth_params    = &ru->eth_params;
executables/nr-ru.c:      ru->ifdevice.configure_rru = configure_ru;
executables/nr-ru.c:      ru->do_prach               = 0;
executables/nr-ru.c:      ru->feprx                  = NULL;                // DFTs
executables/nr-ru.c:      ru->feptx_prec             = nr_feptx_prec;       // Precoding operation
executables/nr-ru.c:      ru->feptx_ofdm             = NULL;                // no OFDM mod
executables/nr-ru.c:      ru->fh_south_in            = fh_if4p5_south_in;   // synchronous IF4p5 reception
executables/nr-ru.c:      ru->fh_south_out           = fh_if4p5_south_out;  // synchronous IF4p5 transmission
executables/nr-ru.c:      ru->fh_south_asynch_in     = (ru->if_timing == synch_to_other) ? fh_if4p5_south_in : NULL;                // asynchronous UL if synch_to_other
executables/nr-ru.c:      ru->fh_north_out           = NULL;
executables/nr-ru.c:      ru->fh_north_asynch_in     = NULL;
executables/nr-ru.c:      ru->start_rf               = NULL;                // no local RF
executables/nr-ru.c:      ru->stop_rf                = NULL;
executables/nr-ru.c:      ru->start_write_thread     = NULL;
executables/nr-ru.c:      ru->nr_start_if            = nr_start_if;         // need to start if interface for IF4p5
executables/nr-ru.c:      ru->ifdevice.host_type     = RAU_HOST;
executables/nr-ru.c:      ru->ifdevice.eth_params    = &ru->eth_params;
executables/nr-ru.c:      ru->ifdevice.configure_rru = configure_ru;
executables/nr-ru.c:      LOG_E(PHY,"RU with invalid or unknown southbound interface type %d\n",ru->if_south);
executables/nr-ru.c:    ru->rf_config_file = rf_config_file;
executables/nr-ru.c:    ru->idx            = ru_id;
executables/nr-ru.c:    ru->ts_offset      = 0;
executables/nr-ru.c:    if (ru->num_gNB > 0) {
executables/nr-ru.c:      LOG_D(PHY, "%s() RC.ru[%d].num_gNB:%d ru->gNB_list[0]:%p RC.gNB[0]:%p rf_config_file:%s\n", __FUNCTION__, ru_id, ru->num_gNB, ru->gNB_list[0], RC.gNB[0], ru->rf_config_file);
executables/nr-ru.c:      if (ru->gNB_list[0] == 0) {
executables/nr-ru.c:        LOG_E(PHY,"%s() DJP - ru->gNB_list ru->num_gNB are not initialized - so do it manually\n", __FUNCTION__);
executables/nr-ru.c:        ru->gNB_list[0] = RC.gNB[0];
executables/nr-ru.c:        ru->num_gNB=1;
executables/nr-ru.c:    gNB0 = ru->gNB_list[0];
executables/nr-ru.c:    fp = ru->nr_frame_parms;
executables/nr-ru.c:    LOG_D(PHY, "RU FUnction:%d ru->if_south:%d\n", ru->function, ru->if_south);
executables/nr-ru.c:      if ((ru->function != NGFI_RRU_IF5) && (ru->function != NGFI_RRU_IF4p5))
executables/nr-ru.c:        LOG_D(PHY, "Copying frame parms from gNB in RC to gNB %d in ru %d and frame_parms in ru\n", gNB0->Mod_id, ru->idx);
executables/nr-ru.c:        LOG_D(PHY,"ru->num_gNB:%d gNB0->num_RU:%d\n", ru->num_gNB, gNB0->num_RU);
executables/nr-ru.c:        for (i=0; i<ru->num_gNB; i++) {
executables/nr-ru.c:          gNB0 = ru->gNB_list[i];
executables/nr-ru.c:    if (ru->if_south != REMOTE_IF4p5) {
executables/nr-ru.c:      int threadCnt = ru->num_tpcores;
executables/nr-ru.c:      int s_offset = sprintf(pool,"%d",ru->tpcores[0]);
executables/nr-ru.c:         s_offset+=sprintf(pool+s_offset,",%d",ru->tpcores[icpu]);
executables/nr-ru.c:      ru->threadPool = (tpool_t*)malloc(sizeof(tpool_t));
executables/nr-ru.c:      initTpool(pool, ru->threadPool, cpumeas(CPUMEAS_GETSTATE));
executables/nr-ru.c:      ru->respfeprx = (notifiedFIFO_t*) malloc(sizeof(notifiedFIFO_t));
executables/nr-ru.c:      initNotifiedFIFO(ru->respfeprx);
executables/nr-ru.c:      ru->respfeptx = (notifiedFIFO_t*) malloc(sizeof(notifiedFIFO_t));
executables/nr-ru.c:      initNotifiedFIFO(ru->respfeptx);
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:        path "/mcap:module-capability/mcap:ru-capabilities/mcap:coupling-methods/mcap:coupling-via-frequency-and-time";
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:    leaf ru-port-bitmask {
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:          path "/o-ran-pe:processing-elements/o-ran-pe:ru-elements/o-ran-pe:name";
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:          path "/o-ran-pe:processing-elements/o-ran-pe:ru-elements/o-ran-pe:name";
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:          path "/mcap:module-capability/mcap:ru-capabilities/mcap:eaxcid-grouping-capabilities/mcap:max-num-tx-eaxc-id-groups";
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:          path "/mcap:module-capability/mcap:ru-capabilities/mcap:eaxcid-grouping-capabilities/mcap:max-num-tx-eaxc-ids-per-group";
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:          path "/mcap:module-capability/mcap:ru-capabilities/mcap:eaxcid-grouping-capabilities/mcap:max-num-rx-eaxc-id-groups";
radio/fhi_72/mplane/yang/models/o-ran-uplane-conf.yang:          path "/mcap:module-capability/mcap:ru-capabilities/mcap:eaxcid-grouping-capabilities/mcap:max-num-rx-eaxc-ids-per-group";
radio/fhi_72/mplane/init-mplane.h:#include "ru-mplane-api.h"
radio/fhi_72/mplane/rpc-send-recv.h:#include "ru-mplane-api.h"
radio/fhi_72/mplane/get-mplane.h:#include "ru-mplane-api.h"
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:      3) Enable number-of-ru-ports to be different between dl and ul
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:      when "/module-capability/ru-capabilities/format-of-iq-sample/realtime-variable-bit-width-supported = 'true'";
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:  grouping ru-capabilities {
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:    leaf ru-supported-category {
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:    leaf number-of-ru-ports {
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:    leaf number-of-ru-ports-ul {
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:    leaf number-of-ru-ports-dl {
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:    container ru-capabilities {
radio/fhi_72/mplane/yang/models/o-ran-module-cap.yang:      uses ru-capabilities;
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:    list ru-elements {
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:          leaf ru-aliasmac-address {
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:          leaf ru-mac-address {
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:            leaf ru-ipv4-address {
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:            leaf ru-ipv6-address {
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:          leaf ru-ephemeral-udp-port {
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:          leaf ru-mac-address {
radio/fhi_72/mplane/yang/models/o-ran-processing-element.yang:          leaf ru-mac-address {
radio/fhi_72/mplane/yang/create-yang-config.c:  ret = lyd_new_list(*root, NULL, "ru-elements", 0, &ru_elem_node, plane_name);
radio/fhi_72/mplane/yang/create-yang-config.c:  VERIFY_SUCCESS(ret == LY_SUCCESS, "[MPLANE] Failed to create \"ru-elements\" node.\n");
radio/fhi_72/mplane/yang/create-yang-config.c:  ret = lyd_new_term(eth_flow, NULL, "ru-mac-address", ru_session->xran_mplane.ru_mac_addr, 0, NULL);
radio/fhi_72/mplane/yang/create-yang-config.c:  VERIFY_SUCCESS(ret == LY_SUCCESS, "[MPLANE] Failed to create \"ru-mac-address\" node.\n");
radio/fhi_72/mplane/yang/create-yang-config.c:  ret = lyd_new_term(eaxc_conf, NULL, "ru-port-bitmask", ru_port_bitmask, 0, NULL);
radio/fhi_72/mplane/yang/create-yang-config.c:  VERIFY_SUCCESS(ret == LY_SUCCESS, "[MPLANE] Failed to create \"ru-port-bitmask\" node.\n");
radio/fhi_72/mplane/config-mplane.h:#include "ru-mplane-api.h"
radio/fhi_72/mplane/connect-mplane.h:#include "ru-mplane-api.h"
radio/fhi_72/mplane/CMakeLists.txt:               ru-mplane-api.c
radio/fhi_72/mplane/subscribe-mplane.h:#include "ru-mplane-api.h"
radio/fhi_72/oran-config.c:#include "mplane/ru-mplane-api.h"
radio/fhi_72/oran_isolate.c:  ru_info.nb_rx = ru->nb_rx;
radio/fhi_72/oran_isolate.c:  ru_info.rxdataF = ru->common.rxdataF;
radio/fhi_72/oran_isolate.c:  ru_info.prach_buf = ru->prach_rxsigF[0]; // index: [prach_oca][ant_id]
radio/fhi_72/oran_isolate.c:  RU_proc_t *proc = &ru->proc;
radio/fhi_72/oran_isolate.c:  start_meas(&ru->rx_fhaul);
radio/fhi_72/oran_isolate.c:  stop_meas(&ru->rx_fhaul);
radio/fhi_72/oran_isolate.c:  int slots_per_frame = 10 << (ru->openair0_cfg.nr_scs_for_raster);
radio/fhi_72/oran_isolate.c:  proc->tti_tx = (sl + ru->sl_ahead) % slots_per_frame;
radio/fhi_72/oran_isolate.c:  proc->frame_tx = (sl > (slots_per_frame - 1 - ru->sl_ahead)) ? (f + 1) & 1023 : f;
radio/fhi_72/oran_isolate.c:  start_meas(&ru->tx_fhaul);
radio/fhi_72/oran_isolate.c:  ru_info.nb_tx = ru->nb_tx;
radio/fhi_72/oran_isolate.c:  ru_info.txdataF_BF = ru->common.txdataF_BF;
radio/fhi_72/oran_isolate.c:  stop_meas(&ru->tx_fhaul);
ci-scripts/yaml_files/lte_b200_tdd_05Mhz_if4.5/docker-compose.yml:        container_name: lte-b200-rru-tdd-05Mhz-tm1
doc/ORAN_FHI7.2_Tutorial.md:SSH to the unit as user `user`. Write `enable` in the terminal to enter the configuration console; the password should be in the user guide. Use the command `show oru-status` to check the RU status. The output should be similar to:
doc/ORAN_FHI7.2_Tutorial.md:# show oru-status 
doc/ORAN_FHI7.2_Tutorial.md:    hardware ethernet <ru-mac-address>;
doc/ORAN_FHI7.2_Tutorial.md:    fixed-address <desired-ru-ip-address>;
doc/ORAN_FHI7.2_Tutorial.md:ssh root@<ru-ip-address>
doc/ORAN_FHI7.2_Tutorial.md:ssh oranbenetel@<ru-ip-address>
doc/ORAN_FHI7.2_Tutorial.md:  ru->>du: 11. RU notifies DU about the configuration change
doc/ORAN_FHI7.2_Tutorial.md:  <ru-elements>
doc/ORAN_FHI7.2_Tutorial.md:        <ru-mac-address>8c:1f:64:d1:11:c0</ru-mac-address>
doc/ORAN_FHI7.2_Tutorial.md:  </ru-elements>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
doc/ORAN_FHI7.2_Tutorial.md:      <ru-port-bitmask>15</ru-port-bitmask>
ci-scripts/yaml_files/lte_b200_fdd_05Mhz_if4.5/docker-compose.yml:        container_name: lte-b200-rru-fdd-05Mhz-tm1
openair1/SIMULATION/NR_PHY/prachsim.c:  ru->nr_frame_parms = frame_parms;
openair1/SIMULATION/NR_PHY/prachsim.c:  ru->if_south       = LOCAL_RF;
openair1/SIMULATION/NR_PHY/prachsim.c:  ru->nb_tx          = n_tx;
openair1/SIMULATION/NR_PHY/prachsim.c:  ru->nb_rx          = n_rx;
openair1/SIMULATION/NR_PHY/prachsim.c:  ru->num_gNB        = 1;
openair1/SIMULATION/NR_PHY/prachsim.c:  ru->gNB_list[0]    = gNB;
openair1/SIMULATION/NR_PHY/prachsim.c:  memcpy((void*)&ru->config,(void*)&RC.gNB[0]->gNB_config,sizeof(ru->config));
openair1/SIMULATION/NR_PHY/prachsim.c:              ((short*) &ru->common.rxdata[aa][rx_prach_start])[2*i] = (short) (.167*(r_re[aa][i] +sqrt(sigma2/2)*gaussdouble(0.0,1.0)));
openair1/SIMULATION/NR_PHY/prachsim.c:              ((short*) &ru->common.rxdata[aa][rx_prach_start])[2*i+1] = (short) (.167*(r_im[aa][i] + (iqim*r_re[aa][i]) + sqrt(sigma2/2)*gaussdouble(0.0,1.0)));
openair1/SIMULATION/NR_PHY/prachsim.c:	  n_bytes = fread(&ru->common.rxdata[0][rx_prach_start],sizeof(int32_t),frame_parms->samples_per_subframe,input_fd);
openair1/SIMULATION/NR_PHY/prachsim.c:			   (int32_t *)ru->common.rxdata[aa],
openair1/SIMULATION/NR_PHY/prachsim.c:			   (int32_t *)ru->common.rxdataF[aa],
openair1/SIMULATION/NR_PHY/prachsim.c:			   ru->N_TA_offset);
openair1/SIMULATION/NR_PHY/prachsim.c:        for (int i = 0; i < ru->nb_rx; ++i)
openair1/SIMULATION/NR_PHY/prachsim.c:          gNB->prach_vars.rxsigF[i] = ru->prach_rxsigF[prachOccasion][i];
openair1/SIMULATION/NR_PHY/prachsim.c:          LOG_M("rxsig0.m","rxs0", &ru->common.rxdata[0][subframe*frame_parms->samples_per_subframe], frame_parms->samples_per_subframe, 1, 1);
openair1/SIMULATION/NR_PHY/prachsim.c:          LOG_M("ru_rxsig0.m","rxs0", &ru->common.rxdata[0][subframe*frame_parms->samples_per_subframe], frame_parms->samples_per_subframe, 1, 1);
openair1/SIMULATION/NR_PHY/prachsim.c:          LOG_M("ru_rxsigF0.m","rxsF0", ru->common.rxdataF[0], frame_parms->ofdm_symbol_size*frame_parms->symbols_per_slot, 1, 1);
openair1/SIMULATION/NR_PHY/prachsim.c:          LOG_M("ru_prach_rxsigF0.m","rxsF0", ru->prach_rxsigF[0][0], N_ZC, 1, 1);
common/utils/T/tracer/hacks/Makefile:all: dump_nack_signal time_meas timeplot multi-rru-clean
common/utils/T/tracer/hacks/Makefile:multi-rru-clean: ../utils.o ../database.o ../event.o ../configuration.o multi-rru-clean.o
common/utils/T/tracer/hacks/Makefile:	rm -f *.o core dump_nack_signal time_meas timeplot multi-rru-clean
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^5.1.1",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.4.4",
common/utils/websrv/frontend/package-lock.json:    "node_modules/@npmcli/git/node_modules/lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.7.1",
common/utils/websrv/frontend/package-lock.json:    "node_modules/cacache/node_modules/lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.5.1"
common/utils/websrv/frontend/package-lock.json:    "node_modules/hosted-git-info/node_modules/lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:    "node_modules/lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.7.1",
common/utils/websrv/frontend/package-lock.json:    "node_modules/make-fetch-happen/node_modules/lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:    "node_modules/nx/node_modules/lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^6.0.0"
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^6.0.0"
common/utils/websrv/frontend/package-lock.json:    "node_modules/semver/node_modules/lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^5.1.1",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.4.4",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": {
common/utils/websrv/frontend/package-lock.json:          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.7.1",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": {
common/utils/websrv/frontend/package-lock.json:          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.5.1"
common/utils/websrv/frontend/package-lock.json:        "lru-cache": {
common/utils/websrv/frontend/package-lock.json:          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:    "lru-cache": {
common/utils/websrv/frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^7.7.1",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": {
common/utils/websrv/frontend/package-lock.json:          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.1.tgz",
common/utils/websrv/frontend/package-lock.json:        "lru-cache": {
common/utils/websrv/frontend/package-lock.json:          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
common/utils/websrv/frontend/package-lock.json:            "lru-cache": "^6.0.0"
common/utils/websrv/frontend/package-lock.json:        "lru-cache": "^6.0.0"
common/utils/websrv/frontend/package-lock.json:        "lru-cache": {
common/utils/websrv/frontend/package-lock.json:          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
openair1/PHY/LTE_TRANSPORT/dlsch_modulation.c:	for (int eNB_id=0;eNB_id<ru->num_eNB;eNB_id++){
openair1/PHY/LTE_TRANSPORT/dlsch_modulation.c:	  if (phy_vars_eNB == ru->eNB_list[eNB_id]) {
openair1/PHY/LTE_TRANSPORT/dlsch_modulation.c:	    for (int aa=0;aa<ru->nb_tx;aa++){
openair1/PHY/LTE_TRANSPORT/dlsch_modulation.c:              LOG_I(PHY,"ru_id:%d eNB_id:%d aa:%d memcpy(ru->beam_weights, dlsch0->ue_spec_bf_weights[ru_id][0],)\n", ru_id, eNB_id, aa);
openair1/PHY/LTE_TRANSPORT/dlsch_modulation.c:	      memcpy(ru->beam_weights[eNB_id][5][aa],
openair1/SCHED/ru_procedures.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
openair1/SCHED/ru_procedures.c:  int subframe = ru->proc.tti_tx;
openair1/SCHED/ru_procedures.c:  //LOG_D(PHY,"SFN/SF:RU:TX:%d/%d Generating slot %d\n",ru->proc.frame_tx, ru->proc.tti_tx,slot);
openair1/SCHED/ru_procedures.c:  for (aa=0; aa<ru->nb_tx; aa++) {
openair1/SCHED/ru_procedures.c:      PHY_ofdm_mod(&ru->common.txdataF_BF[aa][(slot&1)*slot_sizeF],
openair1/SCHED/ru_procedures.c:                   (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED/ru_procedures.c:      if(is_fembms_pmch_subframe(ru->proc.frame_tx,subframe,fp)){
openair1/SCHED/ru_procedures.c:               PHY_ofdm_mod(&ru->common.txdataF_BF[aa][(slot&1)*slot_sizeF],
openair1/SCHED/ru_procedures.c:                       (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED/ru_procedures.c:      } else if(is_pmch_subframe(ru->proc.frame_tx,subframe,fp)){
openair1/SCHED/ru_procedures.c:          normal_prefix_mod(&ru->common.txdataF_BF[aa][(slot&1)*slot_sizeF],
openair1/SCHED/ru_procedures.c:                            (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED/ru_procedures.c:          PHY_ofdm_mod(&ru->common.txdataF_BF[aa][(slot&1)*slot_sizeF+fp->ofdm_symbol_size*2],
openair1/SCHED/ru_procedures.c:                       (int*)&ru->common.txdata[aa][slot_offset+((fp->ofdm_symbol_size>>2)*2+fp->ofdm_symbol_size*2)],
openair1/SCHED/ru_procedures.c:                    ru->proc.frame_tx,
openair1/SCHED/ru_procedures.c:                    ru->proc.tti_tx,
openair1/SCHED/ru_procedures.c:                    is_pmch_subframe(ru->proc.frame_tx,subframe,fp));
openair1/SCHED/ru_procedures.c:         /* AssertFatal(ru->generate_dmrs_sync==1 && (fp->frame_type != TDD || ru->is_slave == 1),
openair1/SCHED/ru_procedures.c:                        "ru->generate_dmrs_sync should not be set, frame_type %d, is_slave %d\n",
openair1/SCHED/ru_procedures.c:                        fp->frame_type,ru->is_slave);
openair1/SCHED/ru_procedures.c:	      if (ru->generate_dmrs_sync == 1 && slot == 2 && aa==0) {
openair1/SCHED/ru_procedures.c:            //int32_t dmrs[ru->frame_parms.ofdm_symbol_size*14] __attribute__((aligned(32)));
openair1/SCHED/ru_procedures.c:            //int32_t *dmrsp[2] ={dmrs,NULL}; //{&dmrs[(3-ru->frame_parms.Ncp)*ru->frame_parms.ofdm_symbol_size],NULL};
openair1/SCHED/ru_procedures.c:                                     ru->common.txdataF_BF,
openair1/SCHED/ru_procedures.c:              normal_prefix_mod(&ru->common.txdataF_BF[aa][(slot&1)*slot_sizeF],
openair1/SCHED/ru_procedures.c:                                (int*)&ru->common.txdata[aa][slot_offset],
openair1/SCHED/ru_procedures.c:      txdata = (int16_t*)&ru->common.txdata[aa][tx_offset];
openair1/SCHED/ru_procedures.c:      txdata = (int16_t*)&ru->common.txdata[aa][0];
openair1/SCHED/ru_procedures.c:      txdata = (int16_t*)&ru->common.txdata[aa][tx_offset];
openair1/SCHED/ru_procedures.c:      for (i=0; i<ru->N_TA_offset; i++) {
openair1/SCHED/ru_procedures.c:	tx_offset = (int)slot_offset+i-ru->N_TA_offset/2;
openair1/SCHED/ru_procedures.c:	ru->common.txdata[aa][tx_offset] = 0x00000000;
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc  = &ru->proc;
openair1/SCHED/ru_procedures.c:    //stop_meas(&ru->ofdm_mod_wakeup_stats);
openair1/SCHED/ru_procedures.c:  LTE_DL_FRAME_PARMS *fp=ru->frame_parms;
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc = &ru->proc;
openair1/SCHED/ru_procedures.c:  start_meas(&ru->ofdm_mod_stats);
openair1/SCHED/ru_procedures.c:    //start_meas(&ru->ofdm_mod_wakeup_stats);
openair1/SCHED/ru_procedures.c:  start_meas(&ru->ofdm_mod_wait_stats);
openair1/SCHED/ru_procedures.c:  stop_meas(&ru->ofdm_mod_wait_stats);
openair1/SCHED/ru_procedures.c:  stop_meas(&ru->ofdm_mod_stats);
openair1/SCHED/ru_procedures.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPTX_OFDM+ru->idx , 0 );
openair1/SCHED/ru_procedures.c:  LTE_DL_FRAME_PARMS *fp=ru->frame_parms;
openair1/SCHED/ru_procedures.c://  int CC_id = ru->proc.CC_id;
openair1/SCHED/ru_procedures.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPTX_OFDM+ru->idx , 1 );
openair1/SCHED/ru_procedures.c:    start_meas(&ru->ofdm_mod_stats);
openair1/SCHED/ru_procedures.c:    for (aa=0; aa<ru->nb_tx; aa++) {
openair1/SCHED/ru_procedures.c:        PHY_ofdm_mod(&ru->common.txdataF_BF[aa][0],
openair1/SCHED/ru_procedures.c:        PHY_ofdm_mod(&ru->common.txdataF_BF[aa][slot_sizeF],
openair1/SCHED/ru_procedures.c:        normal_prefix_mod(&ru->common.txdataF_BF[aa][0],
openair1/SCHED/ru_procedures.c:        PHY_ofdm_mod(&ru->common.txdataF_BF[aa][fp->ofdm_symbol_size*2],
openair1/SCHED/ru_procedures.c:        normal_prefix_mod(&ru->common.txdataF_BF[aa][slot_offset_F],
openair1/SCHED/ru_procedures.c:	  normal_prefix_mod(&ru->common.txdataF_BF[aa][slot_offset_F+slot_sizeF],
openair1/SCHED/ru_procedures.c:	txdata = (int16_t*)&ru->common.txdata[aa][(LTE_NUMBER_OF_SUBFRAMES_PER_FRAME*fp->samples_per_tti)+tx_offset];
openair1/SCHED/ru_procedures.c:	  txdata = (int16_t*)&ru->common.txdata[aa][0];
openair1/SCHED/ru_procedures.c:	txdata = (int16_t*)&ru->common.txdata[aa][tx_offset];
openair1/SCHED/ru_procedures.c:	txdata = (int16_t*)&ru->common.txdata[aa][0];
openair1/SCHED/ru_procedures.c:	txdata = (int16_t*)&ru->common.txdata[aa][tx_offset];
openair1/SCHED/ru_procedures.c:	 ru->common_vars.txdata[0][aa][tx_offset++] = 0x00010001;
openair1/SCHED/ru_procedures.c://       //LOG_D(HW,"subframe %d, time to switch to tx (N_TA_offset %d, slot_offset %d) \n",subframe,ru->N_TA_offset,slot_offset);
openair1/SCHED/ru_procedures.c://       for (i=0; i<ru->N_TA_offset; i++) {
openair1/SCHED/ru_procedures.c://         tx_offset = (int)slot_offset+i-ru->N_TA_offset/2;
openair1/SCHED/ru_procedures.c://         ru->common.txdata[aa][tx_offset] = 0x00000000;
openair1/SCHED/ru_procedures.c:     stop_meas(&ru->ofdm_mod_stats);
openair1/SCHED/ru_procedures.c:	   dB_fixed(signal_energy_nodc((c16_t*)ru->common.txdataF_BF[aa],2*slot_sizeF)));
openair1/SCHED/ru_procedures.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPTX_OFDM+ru->idx , 0 );
openair1/SCHED/ru_procedures.c:  PHY_VARS_eNB **eNB_list = ru->eNB_list, *eNB;
openair1/SCHED/ru_procedures.c:  if (ru->num_eNB == 1)
openair1/SCHED/ru_procedures.c:    VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPTX_PREC+ru->idx , 1);
openair1/SCHED/ru_procedures.c:    for (aa=0;aa<ru->nb_tx;aa++) {
openair1/SCHED/ru_procedures.c:      if (ru->do_precoding == 0) {
openair1/SCHED/ru_procedures.c:          memcpy((void*)ru->common.txdataF_BF[aa],
openair1/SCHED/ru_procedures.c:         memset(ru->common.txdataF_BF[aa],0,sizeof(int32_t)*fp->ofdm_symbol_size*fp->symbols_per_tti);
openair1/SCHED/ru_procedures.c:                             ru->common.txdataF_BF,
openair1/SCHED/ru_procedures.c:                             ru->beam_weights,
openair1/SCHED/ru_procedures.c:                             ru->common.txdataF_BF,
openair1/SCHED/ru_procedures.c:                             ru->beam_weights,
openair1/SCHED/ru_procedures.c:    if(ru->idx<2)
openair1/SCHED/ru_procedures.c:      VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPTX_PREC+ru->idx , 0);
openair1/SCHED/ru_procedures.c:    VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPTX_PREC+ru->idx , 0);
openair1/SCHED/ru_procedures.c:    for (i=0;i<ru->num_eNB;i++) {
openair1/SCHED/ru_procedures.c:	    for (aa=0;aa<ru->nb_tx;aa++) {
openair1/SCHED/ru_procedures.c:                         ru->common.txdataF_BF,
openair1/SCHED/ru_procedures.c:                         ru->beam_weights,
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc        = &ru->proc;
openair1/SCHED/ru_procedures.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc  = &ru->proc;
openair1/SCHED/ru_procedures.c:	//stop_meas(&ru->ofdm_demod_wakeup_stats);
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc = &ru->proc;
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc = &ru->proc;
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc = &ru->proc;
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc = &ru->proc;
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc = &ru->proc;
openair1/SCHED/ru_procedures.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
openair1/SCHED/ru_procedures.c:  RU_CALIBRATION *calibration = &ru->calibration;
openair1/SCHED/ru_procedures.c:  if (ru->idx == 0) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPRX, 1 );
openair1/SCHED/ru_procedures.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPRX+ru->idx, 1 );
openair1/SCHED/ru_procedures.c:  start_meas(&ru->ofdm_demod_stats);
openair1/SCHED/ru_procedures.c:  //start_meas(&ru->ofdm_demod_wakeup_stats);
openair1/SCHED/ru_procedures.c:  start_meas(&ru->ofdm_demod_wait_stats);
openair1/SCHED/ru_procedures.c:  stop_meas(&ru->ofdm_demod_wait_stats);
openair1/SCHED/ru_procedures.c:  if (cpu_meas_enabled == 1 && ru->ofdm_demod_wakeup_stats.p_time > 30 * 3000) {
openair1/SCHED/ru_procedures.c:    print_meas_now(&ru->ofdm_demod_wakeup_stats, "fep wakeup", stdout);
openair1/SCHED/ru_procedures.c:  if (proc->tti_rx/*proc->subframe_rx*/==1 && ru->is_slave==1/* && ru->state == RU_CHECK_SYNC*/)
openair1/SCHED/ru_procedures.c:  	ulsch_extract_rbs_single(ru->common.rxdataF,
openair1/SCHED/ru_procedures.c:                                  /*eNB->ulsch[ru->idx]->cyclicShift,cyclic_shift,0..7*/ 0,
openair1/SCHED/ru_procedures.c:                                  0 /*eNB->ulsch[ru->idx]->rnti rnti or ru->ulsch[eNB_id]->rnti*/);
openair1/SCHED/ru_procedures.c:    check_sync_pos = lte_est_timing_advance_pusch(ru->frame_parms, (c16_t **)ru->calibration.drs_ch_estimates_time);
openair1/SCHED/ru_procedures.c:    if (ru->state == RU_CHECK_SYNC) {
openair1/SCHED/ru_procedures.c:        //    		  LOG_I(PHY,"~~~~~~~~~~~    check_sync_pos %d, frame %d, cnt %d\n",check_sync_pos,proc->frame_rx,ru->wait_check);
openair1/SCHED/ru_procedures.c:        ru->wait_check++;
openair1/SCHED/ru_procedures.c:      LOG_I(PHY, "~~~~~~~~~~~    check_sync_pos %d, frame %d, cnt %d\n", check_sync_pos, proc->frame_rx, ru->wait_check);
openair1/SCHED/ru_procedures.c:      if (ru->wait_check == 20) {
openair1/SCHED/ru_procedures.c:        ru->state = RU_RUN;
openair1/SCHED/ru_procedures.c:        ru->wait_check = 0;
openair1/SCHED/ru_procedures.c:        AssertFatal((ru->ifdevice.trx_ctlsend_func(&ru->ifdevice, &rru_config_msg, rru_config_msg.len) != -1),
openair1/SCHED/ru_procedures.c:                    ru->idx);
openair1/SCHED/ru_procedures.c:            LOG_M("rxdata.m","rxdata",&ru->common.rxdata[0][0], fp->samples_per_tti*2,1,1);
openair1/SCHED/ru_procedures.c:    } else if (ru->state == RU_RUN) {
openair1/SCHED/ru_procedures.c:        LOG_M("rxdata.m", "rxdata", &ru->common.rxdata[0][0], fp->samples_per_tti * 2, 1, 1);
openair1/SCHED/ru_procedures.c:  stop_meas(&ru->ofdm_demod_stats);
openair1/SCHED/ru_procedures.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPRX+ru->idx, 0 );
openair1/SCHED/ru_procedures.c:  LTE_DL_FRAME_PARMS *fp=ru->frame_parms;
openair1/SCHED/ru_procedures.c:  start_meas(&ru->ofdm_demod_stats);
openair1/SCHED/ru_procedures.c:  if (ru->idx == 0) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPRX+ru->idx, 1 );
openair1/SCHED/ru_procedures.c:  if (ru->idx == 0) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PHY_PROCEDURES_RU_FEPRX+ru->idx, 0 );
openair1/SCHED/ru_procedures.c:  stop_meas(&ru->ofdm_demod_stats);
openair1/SCHED/ru_procedures.c:  RU_proc_t *proc = &ru->proc;
openair1/SCHED/ru_procedures.c:  LTE_DL_FRAME_PARMS *fp=ru->frame_parms;
openair1/SCHED/prach_procedures.c:    for (ru_aa=0,aa=0; ru_aa<ru->nb_rx; ru_aa++,aa++) {
openair1/PHY/NR_ESTIMATION/nr_measurements_gNB.c:  if (ru && ru->rfdevice.openair0_cfg) {
openair1/PHY/NR_ESTIMATION/nr_measurements_gNB.c:    rx_gain = ru->rfdevice.openair0_cfg->rx_gain[0];
openair1/PHY/NR_ESTIMATION/nr_measurements_gNB.c:    rx_gain_offset = ru->rfdevice.openair0_cfg->rx_gain_offset[0];
openair1/PHY/NR_ESTIMATION/nr_measurements_gNB.c:  } else if (ru && ru->ifdevice.openair0_cfg) {
openair1/PHY/NR_ESTIMATION/nr_measurements_gNB.c:    rx_gain = ru->ifdevice.openair0_cfg->rx_gain[0];
openair1/PHY/NR_ESTIMATION/nr_measurements_gNB.c:    rx_gain_offset = ru->ifdevice.openair0_cfg->rx_gain_offset[0];
openair1/PHY/INIT/lte_param_init.c:  ru->eNB_list[0] = eNB;
openair1/PHY/INIT/lte_param_init.c:  ru->num_eNB=1;
openair1/PHY/INIT/lte_param_init.c:  ru->frame_parms = frame_parms;
openair1/PHY/INIT/lte_param_init.c:  ru->nb_tx = N_tx_phy;
openair1/PHY/INIT/lte_param_init.c:  ru->nb_rx = N_rx_ru;
openair1/PHY/INIT/lte_param_init.c:  ru->if_south = LOCAL_RF;
openair1/PHY/INIT/lte_param_init.c:    if      (eNB->frame_parms.N_RB_DL == 100) ru->N_TA_offset = 624;
openair1/PHY/INIT/lte_param_init.c:    else if (eNB->frame_parms.N_RB_DL == 50)  ru->N_TA_offset = 624/2;
openair1/PHY/INIT/lte_param_init.c:    else if (eNB->frame_parms.N_RB_DL == 25)  ru->N_TA_offset = 624/4;
openair1/PHY/INIT/lte_param_init.c:  } else ru->N_TA_offset=0;
openair1/PHY/INIT/nr_init_ru.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
openair1/PHY/INIT/nr_init_ru.c:  LOG_D(PHY, "Initializing RU signal buffers (if_south %s) nb_tx %d, nb_rx %d\n", ru_if_types[ru->if_south], ru->nb_tx, ru->nb_rx);
openair1/PHY/INIT/nr_init_ru.c:  nfapi_nr_config_request_scf_t *cfg = &ru->config;
openair1/PHY/INIT/nr_init_ru.c:  ru->nb_log_antennas = 0;
openair1/PHY/INIT/nr_init_ru.c:  for (int n = 0; n < ru->num_gNB; n++) {
openair1/PHY/INIT/nr_init_ru.c:    if (cfg->carrier_config.num_tx_ant.value > ru->nb_log_antennas)
openair1/PHY/INIT/nr_init_ru.c:      ru->nb_log_antennas = cfg->carrier_config.num_tx_ant.value;
openair1/PHY/INIT/nr_init_ru.c:  AssertFatal(ru->nb_log_antennas > 0 && ru->nb_log_antennas < 13, "ru->nb_log_antennas %d ! \n",ru->nb_log_antennas);
openair1/PHY/INIT/nr_init_ru.c:  ru->common.beam_id = malloc16_clear(MAX_NUM_BEAM_PERIODS * sizeof(int*));
openair1/PHY/INIT/nr_init_ru.c:    ru->common.beam_id[i] = malloc16_clear(fp->symbols_per_slot * fp->slots_per_frame * sizeof(int));
openair1/PHY/INIT/nr_init_ru.c:  if (ru->if_south <= REMOTE_IF5) { // this means REMOTE_IF5 or LOCAL_RF, so allocate memory for time-domain signals 
openair1/PHY/INIT/nr_init_ru.c:    ru->common.txdata        = (int32_t**)malloc16(ru->nb_tx*sizeof(int32_t*));
openair1/PHY/INIT/nr_init_ru.c:    ru->common.rxdata        = (int32_t**)malloc16(ru->nb_rx*sizeof(int32_t*) );
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_tx; i++) {
openair1/PHY/INIT/nr_init_ru.c:      ru->common.txdata[i]  = (int32_t*)malloc16_clear((ru->sf_extension + fp->samples_per_frame)*sizeof(int32_t));
openair1/PHY/INIT/nr_init_ru.c:            ru->common.txdata[i],
openair1/PHY/INIT/nr_init_ru.c:            (ru->sf_extension + fp->samples_per_frame) * sizeof(int32_t),
openair1/PHY/INIT/nr_init_ru.c:            ru->sf_extension);
openair1/PHY/INIT/nr_init_ru.c:      ru->common.txdata[i] =  &ru->common.txdata[i][ru->sf_extension];
openair1/PHY/INIT/nr_init_ru.c:      LOG_D(PHY, "[INIT] common.txdata[%d] = %p \n", i, ru->common.txdata[i]);
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_rx; i++) {
openair1/PHY/INIT/nr_init_ru.c:      ru->common.rxdata[i] = (int32_t*)malloc16_clear( fp->samples_per_frame*sizeof(int32_t) );
openair1/PHY/INIT/nr_init_ru.c:    ru->common.txdata        = (int32_t**)NULL;
openair1/PHY/INIT/nr_init_ru.c:    ru->common.rxdata        = (int32_t**)NULL;
openair1/PHY/INIT/nr_init_ru.c:  if (ru->function != NGFI_RRU_IF5) { // we need to do RX/TX RU processing
openair1/PHY/INIT/nr_init_ru.c:    LOG_D(PHY, "nb_tx %d\n", ru->nb_tx);
openair1/PHY/INIT/nr_init_ru.c:    ru->common.rxdata_7_5kHz = (int32_t**)malloc16(ru->nb_rx*sizeof(int32_t*) );
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_rx; i++) {
openair1/PHY/INIT/nr_init_ru.c:      ru->common.rxdata_7_5kHz[i] = (int32_t*)malloc16_clear( 2*fp->samples_per_subframe*2*sizeof(int32_t) );
openair1/PHY/INIT/nr_init_ru.c:      LOG_D(PHY, "rxdata_7_5kHz[%d] %p for RU %d\n", i, ru->common.rxdata_7_5kHz[i], ru->idx);
openair1/PHY/INIT/nr_init_ru.c:    ru->common.txdataF = (int32_t **)malloc16(ru->nb_tx*sizeof(int32_t*));
openair1/PHY/INIT/nr_init_ru.c:    for(int i = 0; i < ru->nb_tx; ++i)
openair1/PHY/INIT/nr_init_ru.c:      ru->common.txdataF[i] = (int32_t*)malloc16_clear(fp->samples_per_frame_wCP * sizeof(int32_t));
openair1/PHY/INIT/nr_init_ru.c:    ru->common.txdataF_BF = (int32_t **)malloc16(ru->nb_tx*sizeof(int32_t*));
openair1/PHY/INIT/nr_init_ru.c:    LOG_D(PHY, "[INIT] common.txdata_BF= %p (%lu bytes)\n", ru->common.txdataF_BF, ru->nb_tx * sizeof(int32_t *));
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_tx; i++) {
openair1/PHY/INIT/nr_init_ru.c:      ru->common.txdataF_BF[i] = (int32_t*)malloc16_clear(fp->samples_per_subframe_wCP*sizeof(int32_t) );
openair1/PHY/INIT/nr_init_ru.c:      LOG_D(PHY, "txdataF_BF[%d] %p for RU %d\n", i, ru->common.txdataF_BF[i], ru->idx);
openair1/PHY/INIT/nr_init_ru.c:    ru->common.rxdataF     = (int32_t**)malloc16(ru->nb_rx*sizeof(int32_t*) );
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_rx; i++) {
openair1/PHY/INIT/nr_init_ru.c:      ru->common.rxdataF[i] = (int32_t*)malloc16_clear(sizeof(**ru->common.rxdataF) * size);
openair1/PHY/INIT/nr_init_ru.c:      LOG_D(PHY, "rxdataF[%d] %p for RU %d\n", i, ru->common.rxdataF[i], ru->idx);
openair1/PHY/INIT/nr_init_ru.c:    //    AssertFatal(ru->nb_rx <= sizeof(ru->prach_rxsigF) / sizeof(ru->prach_rxsigF[0]),
openair1/PHY/INIT/nr_init_ru.c:      ru->prach_rxsigF[j] = (int16_t**)malloc(ru->nb_rx * sizeof(int16_t*));
openair1/PHY/INIT/nr_init_ru.c:      for (int i = 0; i < ru->nb_rx; i++) {
openair1/PHY/INIT/nr_init_ru.c:	ru->prach_rxsigF[j][i] = (int16_t*)malloc16_clear( 4*98304*2*sizeof(int16_t) );
openair1/PHY/INIT/nr_init_ru.c:	LOG_D(PHY,"[INIT] prach_vars->rxsigF[%d] = %p\n",i,ru->prach_rxsigF[j][i]);
openair1/PHY/INIT/nr_init_ru.c:    AssertFatal(ru->num_gNB <= NUMBER_OF_gNB_MAX,"gNB instances %d > %d\n",
openair1/PHY/INIT/nr_init_ru.c:		ru->num_gNB,NUMBER_OF_gNB_MAX);
openair1/PHY/INIT/nr_init_ru.c:    LOG_D(PHY, "[INIT] %s() ru->num_gNB:%d \n", __FUNCTION__, ru->num_gNB);
openair1/PHY/INIT/nr_init_ru.c:  LOG_D(PHY, "Freeing RU signal buffers (if_south %s) nb_tx %d\n", ru_if_types[ru->if_south], ru->nb_tx);
openair1/PHY/INIT/nr_init_ru.c:  if (ru->if_south <= REMOTE_IF5) { // this means REMOTE_IF5 or LOCAL_RF, so free memory for time-domain signals
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_tx; i++) {
openair1/PHY/INIT/nr_init_ru.c:      int32_t *p = &ru->common.txdata[i][-ru->sf_extension];
openair1/PHY/INIT/nr_init_ru.c:    free_and_zero(ru->common.txdata);
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_rx; i++)
openair1/PHY/INIT/nr_init_ru.c:      free_and_zero(ru->common.rxdata[i]);
openair1/PHY/INIT/nr_init_ru.c:    free_and_zero(ru->common.rxdata);
openair1/PHY/INIT/nr_init_ru.c:  if (ru->function != NGFI_RRU_IF5) { // we need to do RX/TX RU processing
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_rx; i++)
openair1/PHY/INIT/nr_init_ru.c:      free_and_zero(ru->common.rxdata_7_5kHz[i]);
openair1/PHY/INIT/nr_init_ru.c:    free_and_zero(ru->common.rxdata_7_5kHz);
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_tx; i++)
openair1/PHY/INIT/nr_init_ru.c:      free_and_zero(ru->common.txdataF[i]);
openair1/PHY/INIT/nr_init_ru.c:    free_and_zero(ru->common.txdataF);
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_tx; i++)
openair1/PHY/INIT/nr_init_ru.c:      free_and_zero(ru->common.txdataF_BF[i]);
openair1/PHY/INIT/nr_init_ru.c:    free_and_zero(ru->common.txdataF_BF);
openair1/PHY/INIT/nr_init_ru.c:    for (int i = 0; i < ru->nb_rx; i++)
openair1/PHY/INIT/nr_init_ru.c:      free_and_zero(ru->common.rxdataF[i]);
openair1/PHY/INIT/nr_init_ru.c:    free_and_zero(ru->common.rxdataF);
openair1/PHY/INIT/nr_init_ru.c:      for (int i = 0; i < ru->nb_rx; i++)
openair1/PHY/INIT/nr_init_ru.c:	free_and_zero(ru->prach_rxsigF[j][i]);
openair1/PHY/INIT/nr_init_ru.c:      free_and_zero(ru->prach_rxsigF[j]);
openair1/PHY/INIT/nr_init_ru.c:      free_and_zero(ru->common.beam_id[i]);
openair1/PHY/INIT/nr_init_ru.c:    free_and_zero(ru->common.beam_id);
openair1/PHY/INIT/nr_init_ru.c:  PHY_VARS_gNB *gNB0 = ru->gNB_list[0];
openair1/PHY/INIT/lte_init_ru.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
openair1/PHY/INIT/lte_init_ru.c:  RU_CALIBRATION *calibration = &ru->calibration;
openair1/PHY/INIT/lte_init_ru.c:  LOG_D(PHY, "Initializing RU signal buffers (if_south %s) nb_tx %d\n", ru_if_types[ru->if_south], ru->nb_tx);
openair1/PHY/INIT/lte_init_ru.c:  if (ru->is_slave == 1) {
openair1/PHY/INIT/lte_init_ru.c:  if (ru->if_south <= REMOTE_IF5) { // this means REMOTE_IF5 or LOCAL_RF, so allocate memory for time-domain signals
openair1/PHY/INIT/lte_init_ru.c:    ru->common.txdata        = (int32_t **)malloc16(ru->nb_tx*sizeof(int32_t *));
openair1/PHY/INIT/lte_init_ru.c:    ru->common.rxdata        = (int32_t **)malloc16(ru->nb_rx*sizeof(int32_t *) );
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->nb_tx; i++) {
openair1/PHY/INIT/lte_init_ru.c:      ru->common.txdata[i]  = (int32_t *)malloc16_clear( fp->samples_per_tti*10*sizeof(int32_t) );
openair1/PHY/INIT/lte_init_ru.c:            ru->common.txdata[i],
openair1/PHY/INIT/lte_init_ru.c:    if (ru->is_slave == 1) {
openair1/PHY/INIT/lte_init_ru.c:      calibration->drs_ch_estimates_time = (int32_t **)malloc16_clear(ru->nb_rx*sizeof(int32_t *));
openair1/PHY/INIT/lte_init_ru.c:      for (i=0; i<ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:      ru->common.rxdata[i] = (int32_t *)malloc16_clear( fp->samples_per_tti*10*sizeof(int32_t) );
openair1/PHY/INIT/lte_init_ru.c:    ru->common.txdata        = (int32_t **)NULL;
openair1/PHY/INIT/lte_init_ru.c:    ru->common.rxdata        = (int32_t **)NULL;
openair1/PHY/INIT/lte_init_ru.c:  if (ru->function != NGFI_RRU_IF5) { // we need to do RX/TX RU processing
openair1/PHY/INIT/lte_init_ru.c:    LOG_D(PHY, "nb_tx %d\n", ru->nb_tx);
openair1/PHY/INIT/lte_init_ru.c:    ru->common.rxdata_7_5kHz = (int32_t **)malloc16(ru->nb_rx*sizeof(int32_t *) );
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:      ru->common.rxdata_7_5kHz[i] = (int32_t *)malloc16_clear( 2*fp->samples_per_tti*2*sizeof(int32_t) );
openair1/PHY/INIT/lte_init_ru.c:      LOG_D(PHY, "rxdata_7_5kHz[%d] %p for RU %d\n", i, ru->common.rxdata_7_5kHz[i], ru->idx);
openair1/PHY/INIT/lte_init_ru.c:    ru->common.txdataF_BF = (int32_t **)malloc16(ru->nb_tx*sizeof(int32_t *));
openair1/PHY/INIT/lte_init_ru.c:    LOG_D(PHY, "[INIT] common.txdata_BF= %p (%lu bytes)\n", ru->common.txdataF_BF, ru->nb_tx * sizeof(int32_t *));
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->nb_tx; i++) {
openair1/PHY/INIT/lte_init_ru.c:      ru->common.txdataF_BF[i] = (int32_t *)malloc16_clear(fp->symbols_per_tti*fp->ofdm_symbol_size*sizeof(int32_t) );
openair1/PHY/INIT/lte_init_ru.c:      LOG_D(PHY, "txdataF_BF[%d] %p for RU %d\n", i, ru->common.txdataF_BF[i], ru->idx);
openair1/PHY/INIT/lte_init_ru.c:    ru->common.rxdataF     = (int32_t **)malloc16(ru->nb_rx*sizeof(int32_t *) );
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:      ru->common.rxdataF[i] = (int32_t *)malloc16_clear(sizeof(int32_t)*(2*fp->ofdm_symbol_size*fp->symbols_per_tti) );
openair1/PHY/INIT/lte_init_ru.c:      LOG_D(PHY, "rxdataF[%d] %p for RU %d\n", i, ru->common.rxdataF[i], ru->idx);
openair1/PHY/INIT/lte_init_ru.c:    if (ru->is_slave == 1) {
openair1/PHY/INIT/lte_init_ru.c:      for (i=0; i<ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:        LOG_D(PHY, "rxdataF_ext[%d] %p for RU %d\n", i, calibration->rxdataF_ext[i], ru->idx);
openair1/PHY/INIT/lte_init_ru.c:    //AssertFatal(ru->nb_rx <= sizeof(ru->prach_rxsigF) / sizeof(ru->prach_rxsigF[0]),
openair1/PHY/INIT/lte_init_ru.c:    ru->prach_rxsigF[0] = (int16_t **)malloc(ru->nb_rx * sizeof(int16_t *));
openair1/PHY/INIT/lte_init_ru.c:    for (j=0; j<4; j++) ru->prach_rxsigF_br[j] = (int16_t **)malloc(ru->nb_rx * sizeof(int16_t *));
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:      ru->prach_rxsigF[0][i] = (int16_t *)malloc16_clear( fp->ofdm_symbol_size*12*2*sizeof(int16_t) );
openair1/PHY/INIT/lte_init_ru.c:      LOG_D(PHY,"[INIT] prach_vars->rxsigF[%d] = %p\n",i,ru->prach_rxsigF[0][i]);
openair1/PHY/INIT/lte_init_ru.c:        ru->prach_rxsigF_br[j][i] = (int16_t *)malloc16_clear( fp->ofdm_symbol_size*12*2*sizeof(int16_t) );
openair1/PHY/INIT/lte_init_ru.c:        LOG_D(PHY,"[INIT] prach_vars_br->rxsigF[%d] = %p\n",i,ru->prach_rxsigF_br[j][i]);
openair1/PHY/INIT/lte_init_ru.c:    AssertFatal(ru->num_eNB <= NUMBER_OF_eNB_MAX,"eNB instances %d > %d\n",
openair1/PHY/INIT/lte_init_ru.c:                ru->num_eNB,NUMBER_OF_eNB_MAX);
openair1/PHY/INIT/lte_init_ru.c:    LOG_D(PHY,"[INIT] %s() ru->num_eNB:%d \n", __FUNCTION__, ru->num_eNB);
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->idx; i++) starting_antenna_index+=ru->nb_tx;
openair1/PHY/INIT/lte_init_ru.c:    for (i=0; i<ru->num_eNB; i++) {
openair1/PHY/INIT/lte_init_ru.c:        LOG_D(PHY,"[INIT] %s() nb_antenna_ports_eNB:%d \n", __FUNCTION__, ru->eNB_list[i]->frame_parms.nb_antenna_ports_eNB);
openair1/PHY/INIT/lte_init_ru.c:        if (p<ru->eNB_list[i]->frame_parms.nb_antenna_ports_eNB || p==5) {
openair1/PHY/INIT/lte_init_ru.c:          LOG_D(PHY,"[INIT] %s() DO BEAM WEIGHTS nb_antenna_ports_eNB:%d nb_tx:%d\n", __FUNCTION__, ru->eNB_list[i]->frame_parms.nb_antenna_ports_eNB, ru->nb_tx);
openair1/PHY/INIT/lte_init_ru.c:          ru->beam_weights[i][p] = (int32_t **)malloc16_clear(ru->nb_tx*sizeof(int32_t *));
openair1/PHY/INIT/lte_init_ru.c:          for (j=0; j<ru->nb_tx; j++) {
openair1/PHY/INIT/lte_init_ru.c:            ru->beam_weights[i][p][j] = (int32_t *)malloc16_clear(fp->ofdm_symbol_size*sizeof(int32_t));
openair1/PHY/INIT/lte_init_ru.c:            //    - antenna port p is mapped to antenna j on ru->idx as: p = (starting_antenna_index+j)%nb_anntena_ports_eNB
openair1/PHY/INIT/lte_init_ru.c:                 (p==((starting_antenna_index+j)%ru->eNB_list[i]->frame_parms.nb_antenna_ports_eNB))) ||
openair1/PHY/INIT/lte_init_ru.c:                ru->beam_weights[i][p][j][re] = 0x00007fff;
openair1/PHY/INIT/lte_init_ru.c:                //LOG_D(PHY,"[INIT] lte_common_vars->beam_weights[%d][%d][%d][%d] = %d\n", i,p,j,re,ru->beam_weights[i][p][j][re]);
openair1/PHY/INIT/lte_init_ru.c:                ru->beam_weights[i][p][j][re] = 0x00007fff/ru->nb_tx;
openair1/PHY/INIT/lte_init_ru.c:                //LOG_D(PHY,"[INIT] lte_common_vars->beam_weights[%d][%d][%d][%d] = %d\n", i,p,j,re,ru->beam_weights[i][p][j][re]);
openair1/PHY/INIT/lte_init_ru.c:            //LOG_D(PHY,"[INIT] lte_common_vars->beam_weights[%d][%d] = %p (%lu bytes)\n", i,j,ru->beam_weights[i][p][j], fp->ofdm_symbol_size*sizeof(int32_t));
openair1/PHY/INIT/lte_init_ru.c:  ru->common.sync_corr = (uint32_t *)malloc16_clear( LTE_NUMBER_OF_SUBFRAMES_PER_FRAME*sizeof(uint32_t)*fp->samples_per_tti );
openair1/PHY/INIT/lte_init_ru.c:  RU_CALIBRATION *calibration = &ru->calibration;
openair1/PHY/INIT/lte_init_ru.c:  LOG_D(PHY, "Freeing RU signal buffers (if_south %s) nb_tx %d\n", ru_if_types[ru->if_south], ru->nb_tx);
openair1/PHY/INIT/lte_init_ru.c:  if (ru->if_south <= REMOTE_IF5) { // this means REMOTE_IF5 or LOCAL_RF, so free memory for time-domain signals
openair1/PHY/INIT/lte_init_ru.c:    for (i = 0; i < ru->nb_tx; i++) free_and_zero(ru->common.txdata[i]);
openair1/PHY/INIT/lte_init_ru.c:    for (i = 0; i < ru->nb_rx; i++) free_and_zero(ru->common.rxdata[i]);
openair1/PHY/INIT/lte_init_ru.c:    if (ru->is_slave == 1) {
openair1/PHY/INIT/lte_init_ru.c:      for (i = 0; i < ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:    free_and_zero(ru->common.txdata);
openair1/PHY/INIT/lte_init_ru.c:    free_and_zero(ru->common.rxdata);
openair1/PHY/INIT/lte_init_ru.c:  if (ru->function != NGFI_RRU_IF5) { // we need to do RX/TX RU processing
openair1/PHY/INIT/lte_init_ru.c:    for (i = 0; i < ru->nb_rx; i++) free_and_zero(ru->common.rxdata_7_5kHz[i]);
openair1/PHY/INIT/lte_init_ru.c:    free_and_zero(ru->common.rxdata_7_5kHz);
openair1/PHY/INIT/lte_init_ru.c:    for (i = 0; i < ru->nb_tx; i++) free_and_zero(ru->common.txdataF_BF[i]);
openair1/PHY/INIT/lte_init_ru.c:    free_and_zero(ru->common.txdataF_BF);
openair1/PHY/INIT/lte_init_ru.c:    for (i = 0; i < ru->nb_rx; i++) free_and_zero(ru->common.rxdataF[i]);
openair1/PHY/INIT/lte_init_ru.c:    free_and_zero(ru->common.rxdataF);
openair1/PHY/INIT/lte_init_ru.c:    if (ru->is_slave == 1) {
openair1/PHY/INIT/lte_init_ru.c:      for (i = 0; i < ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:    for (i = 0; i < ru->nb_rx; i++) {
openair1/PHY/INIT/lte_init_ru.c:      free_and_zero(ru->prach_rxsigF[0][i]);
openair1/PHY/INIT/lte_init_ru.c:      for (j = 0; j < 4; j++) free_and_zero(ru->prach_rxsigF_br[j][i]);
openair1/PHY/INIT/lte_init_ru.c:    for (j = 0; j < 4; j++) free_and_zero(ru->prach_rxsigF_br[j]);
openair1/PHY/INIT/lte_init_ru.c:    free_and_zero(ru->prach_rxsigF[0]);
openair1/PHY/INIT/lte_init_ru.c:    /* ru->prach_rxsigF_br is not allocated -> don't free */
openair1/PHY/INIT/lte_init_ru.c:    for (i = 0; i < ru->num_eNB; i++) {
openair1/PHY/INIT/lte_init_ru.c:        if (p < ru->eNB_list[i]->frame_parms.nb_antenna_ports_eNB || p == 5) {
openair1/PHY/INIT/lte_init_ru.c:          for (j=0; j<ru->nb_tx; j++) free_and_zero(ru->beam_weights[i][p][j]);
openair1/PHY/INIT/lte_init_ru.c:          free_and_zero(ru->beam_weights[i][p]);
openair1/PHY/INIT/lte_init_ru.c:  free_and_zero(ru->common.sync_corr);
openair1/PHY/MODULATION/ul_7_5_kHz.c:  c16_t **rxdata=(c16_t **)ru->common.rxdata;
openair1/PHY/MODULATION/ul_7_5_kHz.c:  c16_t **rxdata_7_5kHz=(c16_t **)ru->common.rxdata_7_5kHz;
openair1/PHY/MODULATION/ul_7_5_kHz.c:  LTE_DL_FRAME_PARMS *frame_parms=ru->frame_parms;
openair1/PHY/MODULATION/ul_7_5_kHz.c:  uint32_t slot_offset = ((uint32_t)slot * frame_parms->samples_per_tti/2)-ru->N_TA_offset;
openair1/PHY/MODULATION/ul_7_5_kHz.c:  for (uint8_t aa=0; aa<ru->nb_rx; aa++) {
openair1/PHY/MODULATION/ul_7_5_kHz.c:    if (ru->is_slave == 1 && slot == 2){
openair1/SIMULATION/LTE_PHY/ulsim.c:            ru->proc.frame_rx = 1;
openair1/SIMULATION/LTE_PHY/ulsim.c:            ru->proc.tti_rx = subframe;
openair1/SIMULATION/LTE_PHY/ulsim.c:              ((short *) &ru->common.rxdata[aa][(frame_parms->samples_per_tti<<1) -frame_parms->ofdm_symbol_size])[2*i] = (short) ((sqrt(sigma2/2)*gaussdouble(0.0,1.0)));
openair1/SIMULATION/LTE_PHY/ulsim.c:              ((short *) &ru->common.rxdata[aa][(frame_parms->samples_per_tti<<1) -frame_parms->ofdm_symbol_size])[2*i+1] = (short) ((sqrt(sigma2/2)*gaussdouble(0.0,1.0)));
openair1/SIMULATION/LTE_PHY/ulsim.c:              ((short *) &ru->common.rxdata[aa][eNB->frame_parms.samples_per_tti*subframe])[2*i] =
openair1/SIMULATION/LTE_PHY/ulsim.c:              ((short *) &ru->common.rxdata[aa][eNB->frame_parms.samples_per_tti*subframe])[2*i+1] =
openair1/SIMULATION/LTE_PHY/ulsim.c:                ((short *) &ru->common.rxdata[aa][eNB->frame_parms.samples_per_tti*(subframe+1)%10])[2*i] =
openair1/SIMULATION/LTE_PHY/ulsim.c:                ((short *) &ru->common.rxdata[aa][eNB->frame_parms.samples_per_tti*(subframe+1)%10])[2*i+1] =
openair1/SIMULATION/LTE_PHY/ulsim.c:                   &ru->common.rxdata[0][(eNB->frame_parms.samples_per_tti<<1) -
openair1/SIMULATION/LTE_PHY/ulsim.c:                   10*log10(signal_energy((int *)&ru->common.rxdata[0][160+(eNB->frame_parms.samples_per_tti*subframe)],
openair1/SIMULATION/LTE_PHY/ulsim.c:          SNRmeas = 10*log10(((double)signal_energy((int *)&ru->common.rxdata[0][160+(eNB->frame_parms.samples_per_tti*subframe)],
openair1/SIMULATION/LTE_PHY/ulsim.c:                                  &ru->common.rxdata[0][(eNB->frame_parms.samples_per_tti<<1) -eNB->frame_parms.ofdm_symbol_size],
openair1/SIMULATION/LTE_PHY/ulsim.c:            LOG_M("rxsig0UL.m","rxs0", &ru->common.rxdata[0][eNB->frame_parms.samples_per_tti*subframe],eNB->frame_parms.samples_per_tti,1,1);
openair1/SIMULATION/LTE_PHY/ulsim.c:            if (eNB->frame_parms.nb_antennas_rx>1) LOG_M("rxsig1UL.m","rxs1", &ru->common.rxdata[1][eNB->frame_parms.samples_per_tti*subframe],eNB->frame_parms.samples_per_tti,1,1);
openair1/SIMULATION/LTE_PHY/ulsim.c:          ru->feprx = (get_thread_worker_conf() == WORKER_ENABLE) ? ru_fep_full_2thread        : fep_full;
openair1/SIMULATION/LTE_PHY/ulsim.c:          ru->feprx(ru,subframe);
openair1/SIMULATION/LTE_PHY/ulsim.c:        double t_rx_fft = inMicroS(ru->ofdm_demod_stats.p_time);
openair1/SIMULATION/LTE_PHY/ulsim.c:        printDistribution(&ru->ofdm_demod_stats,table_rx_fft,"|__ OFDM_demod time");
openair1/SIMULATION/LTE_PHY/ulsim.c:                ru->ofdm_demod_stats.trials,
openair1/SIMULATION/LTE_PHY/ulsim.c:                get_time_meas_us(&ru->ofdm_demod_stats),
openair1/SIMULATION/LTE_PHY/ulsim.c:                squareRoot(&ru->ofdm_demod_stats),
openair1/SIMULATION/LTE_PHY/ulsim.c:  pthread_cond_signal(&ru->proc.cond_fep[0]);
openair1/PHY/LTE_TRANSPORT/prach.c:    fp    = (ru->frame_parms);
openair1/PHY/LTE_TRANSPORT/prach.c:    nb_rx = ru->nb_rx;
openair1/PHY/LTE_TRANSPORT/prach.c:      rxsigF            = ru->prach_rxsigF_br[ce_level];
openair1/PHY/LTE_TRANSPORT/prach.c:      rxsigF            = ru->prach_rxsigF[0];
openair1/PHY/LTE_TRANSPORT/prach.c:    if (ru->if_south == LOCAL_RF || ru->function == NGFI_RAU_IF5) { // set the time-domain signal if we have to use it in this node
openair1/PHY/LTE_TRANSPORT/prach.c:      prach[aa] = (int16_t *)&ru->common.rxdata[aa][(subframe*fp->samples_per_tti)-ru->N_TA_offset];
openair1/PHY/LTE_TRANSPORT/prach.c:        int8_t rach_dBm = dBEn0 - ru->rx_total_gain_dB;
openair1/PHY/LTE_TRANSPORT/prach.c:                ru->idx,br_flag,ce_level,frame_prach,subframe,fp->samples_per_tti,
openair1/PHY/LTE_TRANSPORT/prach.c:                prach[aa],dBEn0,ru->N_TA_offset,buffer,ru->common.rxdata[aa],
openair1/PHY/LTE_TRANSPORT/prach.c:                (subframe*fp->samples_per_tti)-ru->N_TA_offset);
openair1/PHY/LTE_TRANSPORT/prach.c:  if (((eNB!=NULL) && (ru->function != NGFI_RAU_IF4p5))||
openair1/PHY/LTE_TRANSPORT/prach.c:      ((eNB==NULL) && (ru->function == NGFI_RRU_IF4p5))) { // compute the DFTs of the PRACH temporal resources
openair1/PHY/LTE_TRANSPORT/prach.c:  if ((eNB==NULL)  && ru->function == NGFI_RRU_IF4p5) {
openair1/PHY/LTE_TRANSPORT/prach.c:        LOG_M("SF2_3.m","sf2_3",&ru->common.rxdata[0][2*fp->samples_per_tti],2*fp->samples_per_tti,1,1);
openair1/PHY/LTE_TRANSPORT/prach.c:    subframe= br_flag?ru->proc.subframe_prach_br:ru->proc.subframe_prach;
openair1/PHY/LTE_TRANSPORT/prach.c:  int frame_prach=eNB?eNB->proc.frame_prach: ru->proc.frame_prach;
openair1/SIMULATION/LTE_PHY/mbmssim.c:    for (aa=0; aa<ru->frame_parms.nb_antennas_tx; aa++) {
openair1/SIMULATION/LTE_PHY/mbmssim.c:        s_re[aa][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) + (i<<1)]);
openair1/SIMULATION/LTE_PHY/mbmssim.c:        s_im[aa][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)+1]);
openair1/SIMULATION/LTE_PHY/mbmssim.c:            r_re[aarx][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)]);
openair1/SIMULATION/LTE_PHY/mbmssim.c:            r_im[aarx][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)+1]);
openair1/SIMULATION/LTE_PHY/mbmssim.c:            r_re[aarx][i] += ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)]);
openair1/SIMULATION/LTE_PHY/mbmssim.c:            r_im[aarx][i] += ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)+1]);
openair1/SIMULATION/LTE_PHY/mbmssim.c:      freq_channel(eNB2UE[0], ru->frame_parms.N_RB_DL,2*ru->frame_parms.N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/mbmssim.c:      for (u=0; u<2*ru->frame_parms.N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/mbmssim.c:        freq_channel(eNB2UE[1], ru->frame_parms.N_RB_DL,2*ru->frame_parms.N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/mbmssim.c:        for (u=0; u<2*ru->frame_parms.N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/mbmssim.c:        freq_channel(eNB2UE[2], ru->frame_parms.N_RB_DL,2*ru->frame_parms.N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/mbmssim.c:        for (u=0; u<2*ru->frame_parms.N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/mbmssim.c:        freq_channel(eNB2UE[3], ru->frame_parms.N_RB_DL,2*ru->frame_parms.N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/mbmssim.c:        for (u=0; u<2*ru->frame_parms.N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/mbmssim.c:  sigma2_dB = 10*log10((double)tx_lev) +10*log10((double)ru->frame_parms.ofdm_symbol_size/(double)(ru->frame_parms.N_RB_DL*12)) - SNR;
openair1/SIMULATION/LTE_PHY/mbmssim.c:    for (aa=0; aa<ru->nb_tx; aa++)
openair1/SIMULATION/LTE_PHY/mbmssim.c:      for (re=0; re<ru->frame_parms.ofdm_symbol_size; re++)
openair1/SIMULATION/LTE_PHY/mbmssim.c:        ru->beam_weights[0][0][aa][re] = 0x00007fff/eNB->frame_parms.nb_antennas_tx;
openair1/SIMULATION/LTE_PHY/mbmssim.c:    ru->do_precoding=0;
openair1/SIMULATION/LTE_PHY/mbmssim.c:    ru->do_precoding=1;
openair1/SIMULATION/LTE_PHY/mbmssim.c:	     UE->measurements.n0_power_tot_dB =  10*log10((double)tx_lev) +10*log10((double)ru->frame_parms.ofdm_symbol_size/(double)(ru->frame_parms.N_RB_DL*12)) - SNR;
openair1/SIMULATION/LTE_PHY/mbmssim.c:            UE->measurements.n0_power_tot = pow(10,( 10*log10((double)tx_lev) +10*log10((double)ru->frame_parms.ofdm_symbol_size/(double)(ru->frame_parms.N_RB_DL*12)) - SNR)/10);		
openair1/SIMULATION/LTE_PHY/mbmssim.c:            ru->proc.subframe_tx=subframe;
openair1/SIMULATION/LTE_PHY/mbmssim.c:            memcpy((void *)&ru->frame_parms,(void *)&eNB->frame_parms,sizeof(LTE_DL_FRAME_PARMS));
openair1/SIMULATION/LTE_PHY/mbmssim.c: 	    LOG_W(PHY,"RU %d\n",ru->frame_parms.num_MBSFN_config);
openair1/SIMULATION/LTE_PHY/mbmssim.c: 	    LOG_W(PHY,"RU %d\n",ru->frame_parms.NonMBSFN_config_flag);
openair1/SIMULATION/LTE_PHY/mbmssim.c:            ru->proc.subframe_tx=(subframe+1)%10;
openair1/SIMULATION/LTE_PHY/mbmssim.c:              tx_lev += signal_energy(&ru->common.txdata[aa]
openair1/SIMULATION/LTE_PHY/mbmssim.c:              LOG_M("txsig0.m","txs0", &ru->common.txdata[0][subframe* eNB->frame_parms.samples_per_tti], eNB->frame_parms.samples_per_tti,1,1);
openair1/SIMULATION/LTE_PHY/mbmssim.c:                LOG_M("txsigF0.m","txsF0x", &ru->common.txdataF_BF[0][subframe*nsymb*eNB->frame_parms.ofdm_symbol_size],nsymb*eNB->frame_parms.ofdm_symbol_size,1,1);
openair1/SIMULATION/LTE_PHY/mbmssim.c:                LOG_M("txsigF0.m","txsF0", &ru->common.txdataF_BF[5][subframe*nsymb*eNB->frame_parms.ofdm_symbol_size],nsymb*eNB->frame_parms.ofdm_symbol_size,1,1);
openair1/SIMULATION/LTE_PHY/mbmssim.c:                LOG_M("txsigF0_BF.m","txsF0_BF", &ru->common.txdataF_BF[0][0],eNB->frame_parms.ofdm_symbol_size,1,1);
openair1/SIMULATION/LTE_PHY/dlsim.c:    for (aa=0; aa<ru->frame_parms->nb_antennas_tx; aa++) {
openair1/SIMULATION/LTE_PHY/dlsim.c:        s_re[aa][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) + (i<<1)]);
openair1/SIMULATION/LTE_PHY/dlsim.c:        s_im[aa][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)+1]);
openair1/SIMULATION/LTE_PHY/dlsim.c:            r_re[aarx][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)]);
openair1/SIMULATION/LTE_PHY/dlsim.c:            r_im[aarx][i] = ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)+1]);
openair1/SIMULATION/LTE_PHY/dlsim.c:            r_re[aarx][i] += ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)]);
openair1/SIMULATION/LTE_PHY/dlsim.c:            r_im[aarx][i] += ((double)(((short *)ru->common.txdata[aa]))[(2*subframe*UE->frame_parms.samples_per_tti) +(i<<1)+1]);
openair1/SIMULATION/LTE_PHY/dlsim.c:      freq_channel(eNB2UE[0], ru->frame_parms->N_RB_DL,2*ru->frame_parms->N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/dlsim.c:      for (u=0; u<2*ru->frame_parms->N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/dlsim.c:        freq_channel(eNB2UE[1], ru->frame_parms->N_RB_DL,2*ru->frame_parms->N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/dlsim.c:        for (u=0; u<2*ru->frame_parms->N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/dlsim.c:        freq_channel(eNB2UE[2], ru->frame_parms->N_RB_DL,2*ru->frame_parms->N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/dlsim.c:        for (u=0; u<2*ru->frame_parms->N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/dlsim.c:        freq_channel(eNB2UE[3], ru->frame_parms->N_RB_DL,2*ru->frame_parms->N_RB_DL + 1, 15);
openair1/SIMULATION/LTE_PHY/dlsim.c:        for (u=0; u<2*ru->frame_parms->N_RB_DL; u++) {
openair1/SIMULATION/LTE_PHY/dlsim.c:  sigma2_dB = 10*log10((double)tx_lev) +10*log10((double)ru->frame_parms->ofdm_symbol_size/(double)(ru->frame_parms->N_RB_DL*12)) - SNR;
openair1/SIMULATION/LTE_PHY/dlsim.c:    for (aa=0; aa<ru->nb_tx; aa++)
openair1/SIMULATION/LTE_PHY/dlsim.c:      for (re=0; re<ru->frame_parms->ofdm_symbol_size; re++)
openair1/SIMULATION/LTE_PHY/dlsim.c:        ru->beam_weights[0][0][aa][re] = 0x00007fff/eNB->frame_parms.nb_antennas_tx;
openair1/SIMULATION/LTE_PHY/dlsim.c:    ru->do_precoding=0;
openair1/SIMULATION/LTE_PHY/dlsim.c:    ru->do_precoding=1;
openair1/SIMULATION/LTE_PHY/dlsim.c:            ru->proc.tti_tx=subframe;
openair1/SIMULATION/LTE_PHY/dlsim.c:            memcpy((void *)ru->frame_parms,(void *)&eNB->frame_parms,sizeof(LTE_DL_FRAME_PARMS));
openair1/SIMULATION/LTE_PHY/dlsim.c:            ru->proc.tti_tx=(subframe+1)%10;
openair1/SIMULATION/LTE_PHY/dlsim.c:              tx_lev += signal_energy(&ru->common.txdata[aa]
openair1/SIMULATION/LTE_PHY/dlsim.c:              LOG_M("txsig0.m","txs0", &ru->common.txdata[0][subframe* eNB->frame_parms.samples_per_tti], eNB->frame_parms.samples_per_tti,1,1);
openair1/SIMULATION/LTE_PHY/dlsim.c:                LOG_M("txsigF0.m","txsF0x", &ru->common.txdataF_BF[0][0],nsymb*eNB->frame_parms.ofdm_symbol_size,1,1);
openair1/SIMULATION/LTE_PHY/dlsim.c:                LOG_M("txsigF0.m","txsF0", &ru->common.txdataF_BF[5][0],nsymb*eNB->frame_parms.ofdm_symbol_size,1,1);
openair1/SIMULATION/LTE_PHY/dlsim.c:                LOG_M("txsigF0_BF.m","txsF0_BF", &ru->common.txdataF_BF[0][0],eNB->frame_parms.ofdm_symbol_size,1,1);
openair1/PHY/MODULATION/slot_fep_ul.c:  RU_COMMON *common=&ru->common;
openair1/PHY/MODULATION/slot_fep_ul.c:  LTE_DL_FRAME_PARMS *fp = ru->frame_parms;
openair1/PHY/MODULATION/slot_fep_ul.c:  for (aa=0; aa<ru->nb_rx; aa++) {
openair2/LAYER2/NR_MAC_gNB/config.c:        txru->dig_beam_weight_Re = config->bw_list[j + i * nb_tx] & 0xffff;
openair2/LAYER2/NR_MAC_gNB/config.c:        txru->dig_beam_weight_Im = (config->bw_list[j + i * nb_tx] >> 16) & 0xffff;
openair2/LAYER2/NR_MAC_gNB/config.c:        LOG_D(NR_MAC, "Beam %d Tx %d Weight (%d, %d)\n", i, j, txru->dig_beam_weight_Re, txru->dig_beam_weight_Im);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  LTE_DL_FRAME_PARMS *fp     = ru->frame_parms;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int32_t **txdataF          = ru->common.txdataF_BF;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int32_t **rxdataF          = ru->common.rxdataF;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int16_t **prach_rxsigF     = ru->prach_rxsigF[0];
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int16_t ***prach_rxsigF_br = ru->prach_rxsigF_br;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  void *tx_buffer            = ru->ifbuffer.tx[subframe&1];
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  void *tx_buffer_prach      = ru->ifbuffer.tx_prach;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  eth_state_t *eth = (eth_state_t *) (ru->ifdevice.priv);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SEND_IF4_RU+ru->idx,1);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    LOG_D(PHY,"send DL_IF4p5: RU %d frame %d, subframe %d\n",ru->idx,frame,subframe);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      for (int antenna_id=0; antenna_id<ru->nb_tx; antenna_id++) {
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      packet_header->frame_status |= (ru->nb_tx-1);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_WRITE_IF0+ru->idx, 1 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      if ((ru->ifdevice.trx_write_func(&ru->ifdevice,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:                                       db_fulllength*ru->nb_tx,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_WRITE_IF0+ru->idx, 0 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    LOG_D(PHY,"send UL_IF4p5: RU %d frame %d, subframe %d\n",ru->idx,frame,subframe);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        for (int aaid=0; aaid<ru->nb_rx; aaid++) {
openair1/PHY/LTE_TRANSPORT/if4_tools.c:          start_meas(&ru->compression);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        stop_meas(&ru->compression);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        packet_header->frame_status |= ru->nb_rx-1;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        //if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_WRITE_IF0+ru->idx, 1 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        start_meas(&ru->transport);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        if ((ru->ifdevice.trx_write_func(&ru->ifdevice,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:                                         db_fulllength*ru->nb_rx,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        stop_meas(&ru->transport);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:        //if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_WRITE_IF0+ru->idx, 0 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      if ((ru->ifdevice.trx_write_func(&ru->ifdevice,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    for (int antenna_id=0; antenna_id<ru->nb_rx; antenna_id++) {
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_WRITE_IF0+ru->idx, 1 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    if ((ru->ifdevice.trx_write_func(&ru->ifdevice,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:                                     db_fulllength*ru->nb_rx,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_WRITE_IF0+ru->idx, 0 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SEND_IF4_RU+ru->idx,0);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  LTE_DL_FRAME_PARMS *fp     = ru->frame_parms;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int32_t **txdataF          = ru->common.txdataF_BF;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int32_t **rxdataF          = ru->common.rxdataF;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int16_t **prach_rxsigF     = ru->prach_rxsigF[0];
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  int16_t ***prach_rxsigF_br = ru->prach_rxsigF_br;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  void *rx_buffer            = ru->ifbuffer.rx;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  eth_state_t *eth = (eth_state_t *) (ru->ifdevice.priv);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_RECV_IF4_RU+ru->idx,1);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  if (ru->function == NGFI_RRU_IF4p5) {
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    db_fulllength = (12*fp->N_RB_DL)*ru->nb_tx;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    db_fulllength = (12*fp->N_RB_UL)*ru->nb_rx;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  LOG_D(PHY,"recv IF4p5: RU %d waiting (%d samples)\n",ru->idx,db_fulllength);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_READ_IF0+ru->idx, 1 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  while (ru->ifdevice.trx_read_func(&ru->ifdevice,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:          ru->cmd = STOP_RU;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  if (ru->idx<=1) VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_TRX_READ_IF0+ru->idx, 0 );
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    db_fulllength/=ru->nb_tx;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    db_halflength/=ru->nb_tx;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    LOG_D(PHY,"DL_IF4p5: RU %d frame %d, subframe %d, symbol %d\n",ru->idx,*frame,*subframe,*symbol_number);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    for (int antenna_id=0; antenna_id<ru->nb_tx; antenna_id++) {
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    db_fulllength/=ru->nb_rx;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    db_halflength/=ru->nb_rx;
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    if (ru->idx==0) LOG_D(PHY,"UL_IF4p5: RU %d : frame %d, subframe %d, symbol %d\n",ru->idx,*frame,*subframe,*symbol_number);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    for (int antenna_id=0; antenna_id<ru->nb_rx; antenna_id++) {
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      LOG_D(PHY,"PULFFT_IF4p5: CC_id %d : frame %d, subframe %d (symbol %d)=> %d dB\n",ru->idx,*frame,*subframe,*symbol_number,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    for (int antenna_id=0; antenna_id<ru->nb_rx; antenna_id++) {
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    if (*frame == 0) LOG_D(PHY,"PRACH_IF4p5: CC_id %d : frame %d, subframe %d => (%d,%d) dB\n",ru->idx,*frame,*subframe,
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    for (idx=0; idx<ru->num_eNB; idx++) ru->wakeup_prach_eNB(ru->eNB_list[idx],ru,*frame,*subframe);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    if (ru->idx==0) LOG_D(PHY,"UL_IF4p5: RU %d : frame %d, subframe %d, PULTICK\n",ru->idx,*frame,*subframe);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_RECV_IF4_RU+ru->idx,0);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:  eth_state_t *eth = (eth_state_t *) (ru->ifdevice.priv);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      ru->ifbuffer.tx[i]       = malloc(RAW_IF4p5_PRACH_SIZE_BYTES*ru->nb_tx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      memset((void *)ru->ifbuffer.tx[i],0,RAW_IF4p5_PRACH_SIZE_BYTES*ru->nb_tx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    ru->ifbuffer.tx_prach = malloc(RAW_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    memset((void *)ru->ifbuffer.tx_prach,0,RAW_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    ru->ifbuffer.rx       = malloc(RAW_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    memset((void *)ru->ifbuffer.rx,0,RAW_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      ru->ifbuffer.tx[i]       = malloc(UDP_IF4p5_PRACH_SIZE_BYTES*ru->nb_tx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:      memset((void *)ru->ifbuffer.tx[i],0,UDP_IF4p5_PRACH_SIZE_BYTES*ru->nb_tx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    ru->ifbuffer.tx_prach = malloc(UDP_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    memset((void *)ru->ifbuffer.tx_prach,0,UDP_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    ru->ifbuffer.rx       = malloc(UDP_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_TRANSPORT/if4_tools.c:    memset((void *)ru->ifbuffer.rx,0,UDP_IF4p5_PRACH_SIZE_BYTES*ru->nb_rx);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  int32_t dmrs[ru->frame_parms->ofdm_symbol_size*14] __attribute__((aligned(32)));
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  //int32_t *dmrsp[2] = {&dmrs[(3-ru->frame_parms->Ncp)*ru->frame_parms->ofdm_symbol_size],NULL};
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  ru->dmrssync = (int16_t *)malloc16_clear(ru->frame_parms->ofdm_symbol_size*2*sizeof(int16_t));
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  ru->dmrs_corr = (uint64_t *)malloc16_clear(ru->frame_parms->samples_per_tti*10*sizeof(uint64_t));
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:                     ru->frame_parms,
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:                     ru->frame_parms->N_RB_DL,
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  switch (ru->frame_parms->N_RB_DL) {
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:      LOG_E(PHY, "Unknown N_RB_DL %d\n", ru->frame_parms->N_RB_DL);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  idft(get_idft(len), (int16_t *)&dmrsp[0][3 * ru->frame_parms->ofdm_symbol_size], ru->dmrssync,
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  AssertFatal(ru->dmrssync!=NULL,"ru->dmrssync is NULL\n");
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  free(ru->dmrssync);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  if (ru->dmrs_corr)
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:    free(ru->dmrs_corr);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  LTE_DL_FRAME_PARMS *frame_parms = ru->frame_parms;
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  RU_CALIBRATION *calibration = &ru->calibration;
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  for (int ar=0; ar<ru->nb_rx; ar++)
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:    memcpy(ru->common.rxdata[ar] + 2 * length, ru->common.rxdata[ar], frame_parms->ofdm_symbol_size);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:    maxval = max(maxval,ru->dmrssync[i]);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:    maxval = max(maxval,-ru->dmrssync[i]);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:  if (ru->state == RU_CHECK_SYNC) {
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:    for (int ar=0; ar<ru->nb_rx; ar++) {
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:      const c16_t *input = ru->state == RU_CHECK_SYNC ?
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:        (c16_t *)ru->dmrssync;
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:      c32_t result = dot_product(input, (c16_t *)&ru->common.rxdata[ar][n], frame_parms->ofdm_symbol_size, shift);
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:    if (ru->dmrs_corr != NULL)
openair1/PHY/LTE_ESTIMATION/lte_sync_time.c:      ru->dmrs_corr[n] = dmrs_corr;
openair1/PHY/NR_TRANSPORT/nr_prach.c:    ru->prach_list[i].frame = -1;
openair1/PHY/NR_TRANSPORT/nr_prach.c:    ru->prach_list[i].slot = -1;
openair1/PHY/NR_TRANSPORT/nr_prach.c:    ru->prach_list[i].num_slots = -1;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  pthread_mutex_init(&ru->prach_list_mutex, NULL);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  pthread_mutex_lock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:    RU_PRACH_list_t *p = ru->prach_list + i;
openair1/PHY/NR_TRANSPORT/nr_prach.c:      pthread_mutex_unlock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:      pthread_mutex_unlock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  pthread_mutex_unlock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  pthread_mutex_lock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].frame = SFN;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].slot = Slot;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].num_slots = (fmt < 4) ? get_long_prach_dur(fmt, ru->nr_frame_parms->numerology_index) : 1;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].fmt = fmt;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].numRA = prach_pdu->num_ra;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].prachStartSymbol = prach_pdu->prach_start_symbol;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].num_prach_ocas = prach_pdu->num_prach_ocas;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  pthread_mutex_unlock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  pthread_mutex_lock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].frame = -1;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  ru->prach_list[prach_id].slot  = -1;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  pthread_mutex_unlock(&ru->prach_list_mutex);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  NR_DL_FRAME_PARMS *fp = ru->nr_frame_parms;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  int16_t *prach[ru->nb_rx];
openair1/PHY/NR_TRANSPORT/nr_prach.c:  int prach_sequence_length = ru->config.prach_config.prach_sequence_length.value;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  int msg1_frequencystart = ru->config.prach_config.num_prach_fd_occasions_list[numRA].k1.value;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  const uint8_t prach_mu = ru->config.prach_config.prach_sub_c_spacing.value;
openair1/PHY/NR_TRANSPORT/nr_prach.c:  rxsigF = ru->prach_rxsigF[prachOccasion];
openair1/PHY/NR_TRANSPORT/nr_prach.c:  AssertFatal(ru->if_south == LOCAL_RF || ru->if_south == REMOTE_IF5,
openair1/PHY/NR_TRANSPORT/nr_prach.c:  for (int aa=0; aa<ru->nb_rx; aa++){ 
openair1/PHY/NR_TRANSPORT/nr_prach.c:    prach[aa] = (int16_t*)&ru->common.rxdata[aa][fp->get_samples_slot_timestamp(slot2, fp, 0) + sample_offset_slot - ru->N_TA_offset];
openair1/PHY/NR_TRANSPORT/nr_prach.c:	  ru->idx,
openair1/PHY/NR_TRANSPORT/nr_prach.c:	  ru->idx,
openair1/PHY/NR_TRANSPORT/nr_prach.c:    LOG_D(PHY, "rx_prach: Doing PRACH FFT for nb_rx:%d Ncp:%d dftlen:%d\n", ru->nb_rx, Ncp, dftlen);
openair1/PHY/NR_TRANSPORT/nr_prach.c:  for (int aa=0; aa<ru->nb_rx; aa++) {
openair1/PHY/TOOLS/nr_phy_scope.c:  genericWaterFall(graph, (scopeSample_t *)p->ru->common.rxdata[0],
openair1/PHY/TOOLS/nr_phy_scope.c:  if (!phy_vars_ru->common.rxdata)
openair1/PHY/TOOLS/nr_phy_scope.c:                           (const scopeSample_t **)phy_vars_ru->common.rxdata,
openair1/PHY/TOOLS/nr_phy_scope.c:                           (const scopeSample_t **)phy_vars_ru->common.rxdataF,
openair1/PHY/TOOLS/imscope/imscope_record.cpp:    scope_params->ru->scopeData = scope;
openair1/PHY/TOOLS/imscope/imscope_init.cpp:    scope_params->ru->scopeData = scope;
